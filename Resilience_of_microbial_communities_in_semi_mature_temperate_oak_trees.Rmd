---
title: "Resilience_of_microbial_communities_in_semi_mature_temperate_oak_trees"
author: "Usman_Hussain"
date: "2025-08-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#loading packages
```{r}
library(tidyr)
library(dada2)
library(seqinr)
library(stringr)
library(writexl)
library(microbiome)
library(dplyr)
library(ShortRead)
library(vegan)
library(ggplot2)
library(ggsignif)
library(vegan)
library(dada2)
library(tidyr)
library(broom)
library(rstatix)
library(ggpubr)
```

#creating files for demultiplexing
```{r}
#Loading sequencing metadata from CSV file - 1 pool at a time
Metadata <- read.csv("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_Pool_4\\Metadata\\Metadata_16S_Pool_4_Updated.csv")

#Making new column called primer_combination and combining Forward_Primer and Reverse_Primer
Metadata$Primer_combination <- paste(Metadata$Forward_Primer, Metadata$Reverse_Primer, sep = "-")
```

#Creating fasta files with a list of forward and reverse primers for demultiplexing
```{r}
#Loading 16S primer sequences
tag_16S <- read.table("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_Primers.csv",
                      sep = ",",
                      header = TRUE)

# Use separate() to split the 'Sequence' column by spaces to separate the tags, spacers and primers
tag_16S <- tag_16S %>%
  separate(col = Sequence, into = paste0("Part_", 1:4), sep = " ", fill = "right")

# the following chunk labels all the new columns and puts all the strings together again for the sequence column
names(tag_16S) <- c("Name", "illumina_adaptor", "tag", "spacer", "primer")
tag_16S <- tag_16S %>%
  mutate(tag_spacer_primer = paste(tag, spacer, primer, sep = ""))

# finds ^F or ^R positions in tag_16S and stores them into a  TRUE/FALSE tables
pos_F_16S <- grepl("^F", tag_16S$Name) # grepl - searches for matching elements 
pos_R_16S <- grepl("^R", tag_16S$Name)

# separate forward and reverse primers and store them into a fast format
pos_F_16S %>% #for pos_F_16S 
  tag_16S$tag_spacer_primer[.] %>% #in tag_16s take out the seq_tag_spa column
  as.list %>% #as.list - generic function to make a list if possible
  seqinr::write.fasta(names = tag_16S$Name[pos_F_16S], #save the list
                      file.out = "F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_Pool_1\\Metadata\\fwd_tag_spacer_primer_16S.fasta")

pos_R_16S %>%
  tag_16S$tag_spacer_primer[.] %>%
  as.list %>%
  seqinr::write.fasta(names = tag_16S$Name[pos_R_16S],
                      file.out = "F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_Pool_1\\Metadata\\rev_tag_spacer_primer_16S.fasta")
```

#Conducting demultiplexing through Ubuntu
```{r}
## Set working directory
#export input_dir=/mnt/f/Bioinformatics/Big_Experiment_Attempt_2/16S_Pool_1/Raw_Sequences  # Input directory
#export output_dir=/mnt/f/Bioinformatics/Big_Experiment_Attempt_2/16S_Pool_1/Processed_Sequences  # Output Directory

# Create a log file with a timestamp to keep track of the output and errors
##log_file="$output_dir/demultiplexing_log_$(date +%Y%m%d_%H%M%S).txt"

## Make a directory for this job's output (if it doesn't exist already)
#mkdir -p $output_dir

## Display information to the terminal and log file
#{
#    echo "Running on host $(hostname)"
#    echo "Time is $(date)"
#    echo "Directory is $(pwd)"
#    echo "Log file is $log_file"
#    echo "Starting the demultiplexing job..."
#    
#    # Start timing the job
#    start_time=$(date +%s)
#    echo "Start Time: $(date)"
#    
#    # Run Cutadapt for demultiplexing with mixed orientation
#    cutadapt --revcomp \
#        -g ^file:$input_dir/fwd_tag_spacer_primer_16S.fasta \
#        -G ^file:$input_dir/rev_tag_spacer_primer_16S.fasta \
#        -o $output_dir/16S_sequences/{name1}-{name2}.R1.fastq.gz \
#        -p $output_dir/16S_sequences/{name1}-{name2}.R2.fastq.gz \
#        $input_dir/UH_16S_P1_FKDN240093188-1A_H2CGNDRX5_L2_1.fq.gz \
#        $input_dir/UH_16S_P1_FKDN240093188-1A_H2CGNDRX5_L2_2.fq.gz
#    
#    # End timing the job
#    end_time=$(date +%s)
#    execution_time=$((end_time - start_time))
#    echo "Demultiplexing job completed in $execution_time seconds"
#    echo "Job End Time is $(date)"
#    
#} > $log_file 2>&1
#
## Alternatively, print the log file path at the end
#echo "Log file created at $log_file"
```

#Removing unkowns to unknown folder
```{r}
# Define the source directory and destination folder
source_dir <- "F:/Bioinformatics/Big_Experiment_Attempt_2/16S_Pool_4/Processed_Sequences/16S_Sequences"
destination_dir <- file.path(source_dir, "Unknown_Files")

# Create the new directory if it doesn't exist
if (!dir.exists(destination_dir)) {
  dir.create(destination_dir)
}

# List all files in the source directory that contain 'unknown' in their name
files_to_move <- list.files(path = source_dir, pattern = "unknown", full.names = TRUE)

# Loop through each file and move it to the new directory
for (file in files_to_move) {
  # Define the destination file path
  dest_file <- file.path(destination_dir, basename(file))
  
  # Move the file
  file.rename(file, dest_file)
}

cat("Files moved successfully.")
```


#Renaming files for consistency
```{r}
#Adding Px_
Metadata$Sample.ID <- paste0("P4_", Metadata$Sample.ID)

# Define the source directory
source_dir <- "F:/Bioinformatics/Big_Experiment_Attempt_2/16S_Pool_4/Processed_Sequences/16S_Sequences"

# List all FASTQ files in the source directory
fastq_files <- list.files(source_dir, pattern = "\\.fastq\\.gz$", full.names = TRUE)

# Loop through each file
for (file_path in fastq_files) {
  
  # Extract filename without the path
  file_name <- basename(file_path)
  
  # Extract the primer combination (everything before .R1 or .R2)
  primer_match <- str_extract(file_name, "^[^\\.]+")
  
  # Replace "_" with "-" in Metadata if needed (assuming inconsistency)
  Metadata$Primer_combination <- gsub("_", "-", Metadata$Primer_combination)
  
  # Find matching row in metadata
  match_idx <- which(Metadata$Primer_combination == primer_match)
  
  if (length(match_idx) == 1) {
    # Extract new sample name
    new_sample_id <- Metadata$Sample.ID[match_idx]
    
    # Extract the read suffix (.R1.fastq.gz or .R2.fastq.gz)
    read_suffix <- str_extract(file_name, "\\.R[12]\\.fastq\\.gz$")
    
    # Create new file name
    new_file_name <- paste0(new_sample_id, read_suffix)
    
    # Define new file path
    new_file_path <- file.path(source_dir, new_file_name)
    
    # Rename the file
    file.rename(file_path, new_file_path)
    
    cat("Renamed:", file_name, "->", new_file_name, "\n")
  } else {
    cat("No match found for:", file_name, "\n")
  }
}
```

#Beginning DADA 2 filtering pipeline
#creating paths to files
``` {r}
# Path to the raw sequences
path <- "F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Raw_Sequences"
# Path to metadata
paf_metadata <- "F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Metadata"
# Path of the output
output <- "F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Processed_Sequences"
```

# Separating forward and reverse reads
```{r}
fqR1 <- list.files(file.path(path, "16S_Sequences"), pattern = "R1.fastq.gz", full.names = T) #forward reads in fqR1
fqR2 <- list.files(file.path(path, "16S_Sequences"), pattern = "R2.fastq.gz", full.names = T) #reverse reads in fqR2
```

#Check quality profile
```{r}
quality_profile <- plotQualityProfile(fqR1[150:151])
quality_profile_2 <- plotQualityProfile(fqR2[1987:1996])
```

#Checking for primers in the sequences
```{r}
# Identify the primers sequences, in 5'-3' orientation
FWD <- "GTGBCAGCMGCCGCGGTAA" #Add the forward primer into FWD
REV <- "GGACTACHVGGGTWTCTAAT" #Add the reverse primer into REV

# Function to reorient the primers
allOrients <- function(primer) {
  # Create all orientations of the input sequence (Forward, complement, reverse and reverse complement)
  require(Biostrings)
  dna <- DNAString(primer)  # The Biostrings works w/ DNAString objects rather than character vectors
  orients <- c(Forward = dna, Complement = complement(dna), Reverse = reverse(dna),
               RevComp = reverseComplement(dna))
  return(sapply(orients, toString))  # Convert back to character vector
}

FWD.orients <- allOrients(FWD)
REV.orients <- allOrients(REV)


library(ShortRead)
primerHits <- function(primer, fn) {
  # Counts number of reads in which the primer is found
  nhits <- vcountPattern(primer, sread(readFastq(fn)), fixed = FALSE)
  return(sum(nhits > 0))
}

# Count the occurrences of the primers sequences in a random sample
sample_to_check<- sample(1:length(fqR1),size = 1)

primer.check<-rbind(
  FWD.R1 = sapply(FWD.orients, primerHits, fn = fqR1[sample_to_check]),
  FWD.R2 = sapply(FWD.orients, primerHits, fn = fqR2[sample_to_check]),
  REV.R1 = sapply(REV.orients, primerHits, fn = fqR1[sample_to_check]),
  REV.R2 = sapply(REV.orients, primerHits, fn = fqR2[sample_to_check])
)

write.table(primer.check, file.path(output, "first.primer.check.16S.txt"))

primer.check
```

#Checking the length of the reads
```{r}
# Specify the directory containing the FASTQ files
directory <- "F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Raw_Sequences\\16S_Sequences"

# List all FASTQ files in the directory
fastq_files <- list.files(directory, pattern = "\\.fastq.gz$", full.names = TRUE)

# Specify the number of files to process
num_files <- 100  # Change this number to control how many files to process

# Ensure we don't exceed the number of available files
num_files <- min(num_files, length(fastq_files))

# Initialize an empty list to store read lengths
all_read_lengths <- list()

# Loop through the specified number of FASTQ files and extract the read lengths
for (i in 1:num_files) {
  file <- fastq_files[i]
  fq <- readFastq(file)
  read_lengths <- width(sread(fq))
  all_read_lengths[[file]] <- data.frame(Length = read_lengths, File = basename(file))
}

# Combine all the data frames into one
df <- bind_rows(all_read_lengths)

# Plot the distribution of read lengths, color-coded by file
plot1 <- ggplot(df, aes(x = Length, fill = File)) +
  geom_histogram(binwidth = 1, color = "black", alpha = 0.7, position = "identity") +
  labs(title = paste("Distribution of Read Lengths Across", num_files, "Files"),
       x = "Read Length",
       y = "Frequency") +
  theme_classic() +  # Use theme_classic for a white background
  theme(legend.position = "",
        plot.background = element_rect(fill = "white"),  # Set plot background to white
        panel.background = element_rect(fill = "white"),  # Set panel background to white
        panel.grid = element_blank()) +  # Remove grid lines if not needed
  xlim(0, 300)

ggsave("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Images\\Length_of_Reads.png", 
       plot1, width = 8, height = 3)
```

#Filtering stage
```{r}
#Filtering

# In this second step of filtering, we remove :
# 
# reads with more than 2 expected errors, based on quality scores,
# reads of less than 75 nucleotides,
# reads that match against the phiX genome (bacteriophage),
# and truncate reads at the first instance of a quality score less than or equal to 2.

#Pathcut
path.cut <- file.path(output, "16S/no_primers")

# Reverse and Forward are inverted with the degenerated primers
filtR1 <- file.path(path.cut, "filtered", basename(fqR1))
filtR2 <- file.path(path.cut, "filtered", basename(fqR2))


#Filter the sequences
out <- filterAndTrim(fqR1, filtR1, fqR2, filtR2, 
                     maxN = 0, # No ambiguous base  
                     maxEE = c(2,2), # No reads with more than 2 expected error (base on bases quality scores)
                     truncQ = 2, # Truncate reads at the first instance of a quality score less than or equal to truncQ.
                     minLen =75 , # min read length
                     rm.phix = TRUE, # discard reads that match against the phiX genome (bacteriophage)
                     compress = TRUE, verbose = TRUE)
# Matrix with cutadapted sequences number and quality filter
colnames(out) <- c("cutadapt","quality")
write.table(out, file.path(output, "stat_count_cutadapt_qualfilt_16S.txt"))

filtR1 <- list.files(paste0(path.cut, "/filtered"), pattern="R1.fastq", full.names=TRUE)
filtR2 <- list.files(paste0(path.cut, "/filtered"), pattern="R2.fastq", full.names=TRUE)

sample.names <- gsub(".*/filtered/(.*).R1.fastq.gz","\\1",filtR1)
names(filtR1) <- sample.names
names(filtR2) <- sample.names
```

#Checking error rate 
```{r}
#Looking at the error rate of the sequencing

#The DADA2 algorithm makes use of a parametric error model (err) and every amplicon dataset has a different set of error rates. The learn Errors method learns this error model from the data, by alternating estimation of the error rates and inference of sample composition until they converge on a jointly consistent solution. As in many machine-learning problems, the algorithm must begin with an initial guess, for which the maximum possible error rates in this data are used (the error rates if only the most abundant sequence is correct and all the rest are errors).

#In parallel

#PCR errors which we can't quantify - we need to estimate the error rate of mutations and errors during PCR according to each individual base and then we will apply these error rates onto the sequence reads to remove errors and make ASV's. 

require(doParallel,quietly = T)
no_cores <- detectCores()-1
cl <- makeCluster(no_cores)
registerDoParallel(cl)

#This chunk is for the reverse reads 
errR1 <- learnErrors(filtR1, multithread=no_cores) #Uses bases in the reads from your samples to learn the error rate
saveRDS(errR1, file.path(output,"errR1_16S.RDS")) #saves error rate into a new R project
plot_errR1 <- plotErrors(errR1, nominalQ=TRUE) #plots the error rates in a graph
ggplot2::ggsave(file.path(output,"plot_errR1_16S.png"),plot_errR1, width = 8, height = 6, dpi = 300)# saves the graphs using ggplot2 and customises the graph

#This chuck is for the forward reads
errR2 <- learnErrors(filtR2, multithread=no_cores) 
saveRDS(errR2, file.path(output,"errR2_16S.RDS"))
plot_errR2 <-plotErrors(errR2, nominalQ=TRUE)
ggplot2::ggsave(file.path(output,"plot_errR2_16S.png"),plot_errR2, width = 8, height = 6, dpi = 300)
```

#Applying the sample inference algorithm with the error rate generated
```{r}
#We are now ready to apply the core sample inference algorithm (the error rate we calculated from the previous chunk of code) to the filtered and trimmed sequence data.

errR1 <- readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Processed_Sequences\\errR1_16S.RDS")
errR2 <- readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Processed_Sequences\\errR2_16S.RDS")

# FORWARD reads
dadaR1 <- dada(filtR1, err=errR1, multithread=TRUE)
saveRDS(dadaR1, file = file.path(output,"dadaR1_16S.RDS"), compress = "gzip")

# REVERSE reads
dadaR2 <- dada(filtR2, err=errR2, multithread=TRUE)
saveRDS(dadaR2, file = file.path(output,"dadaR2_16S.RDS"), compress = "gzip")
```

#Checking length of ASV of forward or reverse reads
```{r}
dadaR1 <- readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Processed_Sequences\\dadaR1_16S.RDS")

dadaR2 <- readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Processed_Sequences\\dadaR2_16S.RDS")

seqtabR1 <- makeSequenceTable(dadaR1)
saveRDS(seqtabR1, file.path(output,"seqtab_16S_DADAR1.RDS"),compress="gzip")

# Inspect distribution of sequence lengths
plot(table(nchar(getSequences(seqtabR1))))

seqtabR2 <- makeSequenceTable(dadaR2)
saveRDS(seqtabR2, file.path(output,"seqtab_16S_DADAR2.RDS"),compress="gzip")

# Inspect distribution of sequence lengths
plot(table(nchar(getSequences(seqtabR2))))
```

#Merging forward and reverse reads
```{r}
#Merge paired reads
mergers <- mergePairs(dadaR1, filtR1, dadaR2, filtR2, verbose=TRUE)
saveRDS(mergers, file = file.path(output,"mergers_16S.RDS"), compress = "gzip")

# Inspect the merger data.frame from the first sample
head(mergers[[1]])
```

#Showing length of merged ASVs
```{r}
#This will show a graph illustrating the length of the ASV's and how many ASV's containing those lengths. For 16S we want most of the ASV's to have a size of 250 bp
seqtab <- makeSequenceTable(mergers)
saveRDS(seqtab, file.path(output,"seqtab_16S.RDS"),compress="gzip")

seqtab <- readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Processed_Sequences\\seqtab_16S.RDS")

# Inspect distribution of sequence lengths
plot(table(nchar(getSequences(seqtab))))
```

# Filter sequences based on length (>225 and <275)
```{r}
seqtab.noShort <- seqtab[, nchar(colnames(seqtab)) > 225 & nchar(colnames(seqtab)) < 275] #filtering between 225 and 275

# Plot a graph to show ASVs between 225 and 275 bp
plot(table(nchar(colnames(seqtab.noShort))))

# Save the filtered sequences to an RDS file
# Replace 'output' with your desired output directory
saveRDS(seqtab.noShort, file.path(output, "seqtab_noShort_16S.RDS"), compress = "gzip")

seqtab.noShort <- readRDS(file.path(output, "seqtab_noShort_16S.RDS"))
plot(table(nchar(colnames(seqtab.noShort))))
```

#Removing chimeras
```{r}
#Removing chimeras - removing sequences which are formed by 2 or more biological sequences joined together. Chimeric sequences are identified if they can be exactly reconstructed by combining a left-segment and a right-segment from two more abundant "parent" sequences.
seqtab.nochim <- removeBimeraDenovo(seqtab.noShort, method="consensus", multithread=TRUE, verbose=TRUE)
dim(seqtab.nochim)
saveRDS(seqtab.nochim, file.path(output,"seqtab_nochim_16S.RDS"),compress="gzip")

sum(seqtab.nochim)/sum(seqtab)
```

#Assign taxonomy
```{r}
seqtab.coll <- readRDS(file.path(output,"seqtab_nochim_16S.RDS"))

#Checking the total values of negative controls 
# Get the number of rows in the dataframe
num_rows <- nrow(seqtab.coll)

# Calculate the sum of the last two rows
last_two_rows_sum <- sum(seqtab.coll[(num_rows - 1):num_rows, ])

print(last_two_rows_sum)

# To the genus level:
taxa <- assignTaxonomy(seqs = seqtab.coll,
                       refFasta = "D:\\PhD_Bioinformatics\\Silva_database\\silva_nr99_v138.1_train_set.fa.gz",
                       multithread=TRUE, verbose = T, tryRC = T, minBoot = 80, 
                       outputBootstraps = T)
saveRDS(taxa, file.path(output,"assignment_16S_SILVA_genus.RDS"), compress=T)

apply(taxa$tax, 2, function(x) sum(is.na(x))) # Check number of unassigned ASV


# At the species rank
chunk.size <- 1000
tax_dada_sp <- do.call(rbind,
                       lapply(split(c(1:nrow(taxa$tax)), sort(c(1:nrow(taxa$tax))%%ceiling(nrow(taxa$tax)/chunk.size))),
                              function(x){
                                return(addSpecies(taxa$tax[x, ], 
                                                  refFasta = "D:\\PhD_Bioinformatics\\Silva_database\\silva_species_assignment_v138.1.fa.gz", 
                                                  tryRC = TRUE))
                              }))

saveRDS(tax_dada_sp, file.path(output, "assignment_16S_SILVA_species.RDS"), compress=T)
apply(tax_dada_sp, 2, function(x) sum(is.na(x)))
```

#Creating phyloseq objects
```{r}
ASV_table <- t(readRDS(file.path(output, "seqtab_nochim_16S.RDS"))) # Loading ASV table

classification_table <- readRDS(file.path(output, "assignment_16S_SILVA_species.RDS")) #Loading classification table

#Loading Metadata
Metadata <- read.table(file.path("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Metadata\\Metadata_All.csv"), sep=",", header=TRUE) 

#Removing extra P2_ which shwos up in the P2 colnames in thie ASV table
colnames(ASV_table) <- sub("^P2_", "", colnames(ASV_table))

# Convert matrix to data frame for easier manipulation
Metadata <- as.data.frame(Metadata)

# Check if '16S_1' exists in the 'Pool' column
if (any(grepl("16S_1", Metadata$Pool))) {
  Metadata$Sample.ID[grepl("16S_1", Metadata$Pool)] <- paste0("P1_", Metadata$Sample.ID[grepl("16S_1", Metadata$Pool)])
}

# Check if '16S_2' exists in the 'Pool' column
if (any(grepl("16S_2", Metadata$Pool))) {
  Metadata$Sample.ID[grepl("16S_2", Metadata$Pool)] <- paste0("P2_", Metadata$Sample.ID[grepl("16S_2", Metadata$Pool)])
}

# Check if '16S_3' exists in the 'Pool' column
if (any(grepl("16S_3", Metadata$Pool))) {
  Metadata$Sample.ID[grepl("16S_3", Metadata$Pool)] <- paste0("P3_", Metadata$Sample.ID[grepl("16S_3", Metadata$Pool)])
}

# Check if '16S_4' exists in the 'Pool' column
if (any(grepl("16S_4", Metadata$Pool))) {
  Metadata$Sample.ID[grepl("16S_4", Metadata$Pool)] <- paste0("P4_", Metadata$Sample.ID[grepl("16S_4", Metadata$Pool)])
}

#anything with 16S in its name, rename to Fx_Ry for both  ASV_table and  - this keeps the names consistent for the unused tag combinations
transform_sample_id <- function(sample_id) {
  if (str_detect(sample_id, "16S")) {
    prefix <- str_extract(sample_id, "P[1-4]_")
    matches <- str_match(sample_id, ".*_F(\\d+)_R(\\d+).*")
    formatted_id <- paste0("F", matches[2], "_R", matches[3])
    if (!is.na(prefix)) {
      formatted_id <- paste0(prefix, formatted_id)
    }
    return(formatted_id)
  }
  return(sample_id)
}

Metadata <- Metadata %>%
  mutate(Sample.ID = sapply(Sample.ID, transform_sample_id))

# Convert matrix to data frame for easier manipulation
ASV_table <- as.data.frame(ASV_table)

# Function to rename columns
rename_columns <- function(col_name) {
  if (str_detect(col_name, "16S")) {
    prefix <- str_extract(col_name, "P[1-4]_")
    F_number <- str_extract(col_name, "F\\d+")
    R_number <- str_extract(col_name, "R\\d+")
    new_name <- paste0(F_number, "_", R_number)
    if (!is.na(prefix)) {
      new_name <- paste0(prefix, new_name)
    }
    return(new_name)
  }
  return(col_name)
}

# Apply the function to column names
new_colnames <- sapply(colnames(ASV_table), rename_columns)

# Set the new column names to the dataframe
colnames(ASV_table) <- new_colnames

#colnames(ASV_table)

#Remove one zymo sample as it was removed in the analysis because there was a space in there

#removing P1_BA_Zymo_Control_Soil in the Sample.ID metadata - this failed in the demultiplexing
Metadata <- Metadata[Metadata$Sample.ID != "P1_BA_Zymo_Control_Soil", , drop = FALSE]

# Get all Sample.ID names from Metadata
all_sample_ids <- Metadata$Sample.ID

#converting to df
all_sample_ids_df <- as.data.frame(all_sample_ids)

#Get the column names from ASV table
col_names <- colnames(ASV_table)

#convert column names to df for ease
col_names_df <- as.data.frame(col_names)

#reorder the df names in alphabetical order
all_sample_ids_df <- all_sample_ids_df[order(all_sample_ids_df$all_sample_ids), ,drop = FALSE]
col_names_df <- col_names_df[order(col_names_df$col_names), , drop = FALSE]

#checking matching names
matching_sample_names <- as.data.frame(intersect(all_sample_ids_df$all_sample_ids, col_names_df$col_names))

#checking names which do not match
non_matching_sample_names <- as.data.frame(setdiff(all_sample_ids_df$all_sample_ids, matching_sample_names$intersect))

#rename row names of Metadata with Sample.ID column
all(unique(Metadata$Sample.ID) == Metadata$Sample.ID)

rownames(Metadata) <- Metadata$Sample.ID

#reordering Metadata rows to match the column names of ASV_table by reordering in alphabetical order
Metadata <- Metadata[order(rownames(Metadata)), ]
ASV_table <- ASV_table[, order(colnames(ASV_table))]

my_phyloseq <- phyloseq(otu_table(ASV_table, taxa_are_rows=TRUE),
                        sample_data(Metadata),
                        tax_table(classification_table))

# Extract metadata
metadata_extract <- as.data.frame(sample_data(my_phyloseq))

# Extract ASV (OTU) table
ASV_table_extract <- as.data.frame(otu_table(my_phyloseq))

# Extract classification table (taxonomy)
classification_table_extract <- as.data.frame(tax_table(my_phyloseq))

saveRDS(my_phyloseq, file.path(output, "my_phyloseq.RDS"), compress = "gzip")
```

#renaming all chloroplast and mitochondria in phyloseq object
```{r}
#For Mitochondria
# Find rows where "Mitochondria" is present in the Family column
mito_rows <- which(classification_table_extract$Family == "Mitochondria")

# Update all other taxa in those rows to "Mitochondria"
classification_table_extract[mito_rows, ] <- t(apply(classification_table_extract[mito_rows, ], 1, function(row) ifelse(!grepl("Mitochondria", row), "Mitochondria", row)))

# Convert back to matrix
classification_table <- as.matrix(classification_table_extract)

# Update tax table in the phyloseq object
tax_table(my_phyloseq) <- classification_table

classification_table_extract <- as.data.frame(tax_table(my_phyloseq))

#For Chloroplast
# Convert tax table to data frame
classification_table_df <- as.data.frame(tax_table(my_phyloseq))

# Find rows where "Chloroplast" is present in the Order column
chloro_rows <- which(classification_table_df$Order == "Chloroplast")

# Update all other taxa in those rows to "Chloroplast"
classification_table_df[chloro_rows, ] <- t(apply(classification_table_df[chloro_rows, ], 1, function(row) ifelse(!grepl("Chloroplast", row), "Chloroplast", row)))

# Convert back to matrix
classification_table <- as.matrix(classification_table_df)

# Update tax table in the phyloseq object
tax_table(my_phyloseq) <- classification_table

classification_table_extract <- as.data.frame(tax_table(my_phyloseq))

#saving_phyloseq_object with plastids
saveRDS(my_phyloseq, file.path(output,"Phyloseq_with_plastid.RDS"))
```

#Removing chloroplast and mitochondria ASVs
```{r}
# Filter out chloroplast and mitochondria taxa from the taxonomic table
filtered_tax_table <- tax_table(my_phyloseq)[
  !(tax_table(my_phyloseq)[, "Family"] == "Mitochondria" | 
    tax_table(my_phyloseq)[, "Order"] == "Chloroplast"), ]

# Remove duplicated taxa names
filtered_tax_table <- filtered_tax_table[!duplicated(rownames(filtered_tax_table)), ]

# Get the row names of the OTU table for taxa to keep
taxa_to_keep <- rownames(filtered_tax_table)

# Filter the OTU table based on the taxa to keep
filtered_otu_table <- prune_taxa(taxa_to_keep, otu_table(my_phyloseq))

# Create the filtered phyloseq object
filtered_phyloseq <- phyloseq(filtered_otu_table, sample_data(my_phyloseq), filtered_tax_table)

saveRDS(filtered_phyloseq, file.path(output,"Phyloseq_without_plastid.RDS"))
```

#Filtering data by minimum 100
```{r}
filtered_phyloseq <- readRDS(file.path(output,"Phyloseq_without_plastid.RDS"))

ps_minimum <- filter_taxa(filtered_phyloseq, \(x) any(x > 150), prune = TRUE)

saveRDS(ps_minimum, file.path(output,"Phyloseq_without_plastid_100.RDS"))
```

#Splitting phyloseq object into pools for tag_jumping
```{r}
ps_minimum <- readRDS(file.path(output,"Phyloseq_without_plastid_100.RDS"))

ps_minimum_P1 <- microViz::ps_filter(ps_minimum, Pool == "16S_1")

ps_minimum_P2 <- microViz::ps_filter(ps_minimum, Pool == "16S_2")

ps_minimum_P3 <- microViz::ps_filter(ps_minimum, Pool == "16S_3")

ps_minimum_P4 <- microViz::ps_filter(ps_minimum, Pool == "16S_4")

metadata_extract <- as.data.frame(sample_data(ps_minimum_P1))
```

#Tag-jumping functions
```{r}
library(microViz)
#Creating function called estimate_colprods - To estimate tag-jumping prediction factor
estimate_colprods <- function(ps) {
  phylo_long_colprods <- ps |> #Inputs a phyloseq object 
    phyloseq::psmelt() |> #Convert phyloseq object into a long format data frame 
    as_tibble() |> #Converts the the data frame into a tibble format
    mutate(sum_f = sum(Abundance), .by = "Forward_Primer") |> #Creates a new column called sum_f in the tibble which contains the sum of the Abundance values. .by=F sum is calculated for each unique value of the F (forward primer) variable
    mutate(sum_r = sum(Abundance), .by = "Reverse_Primer") |> #Repeated but for the reverse primer values
    mutate(fr = log10(sum_f) + log10(sum_r),#Adds fr to column, calculates log of sum of abundance of F and R and adds them together
           fr_scale = scale(fr)[,1]) #This creates a new column called fr_scale, and scales values using the scale function and only keeps the scaled values- subtracts the mean and divides everything by the standard deviation
  
  phylo_long_colprods #Function returns modified tibble
}


#Creating a function called add_occupancy_thresholds- Which takes two inputs (original data and predicted data) and calculates a threshold based on specified quantile, adds #these thresholds as a new column to the original data, and returns the modified data frame
add_occupancy_thresholds <- function(ps_long, ps_predictions, pred_quantile = 0.5) {
  thresholds <- apply(ps_predictions, 2, quantile, probs = pred_quantile) |> 
    round()
  
  ps_long$OccThresh <- thresholds
  
  return(ps_long)
}


#Creates a function for filtering a phyloseq object to include only "Sample" from SampleType, arranged the the samples by category wish you wish to arrange and then 
ps_correct_tj <- function(ps, ps_long_preds) {
  ## Filter and arrange PS object
  ps_filt <- ps |> 
    microViz::ps_filter(SampleType == "Sample", .keep_all_taxa = TRUE) |> 
    microViz::ps_arrange(Number) |>
    microViz::tax_sort() |> phyloseq::t()
  
  ## Build matrix!
  thresh_tbl <- ps_long_preds |> 
    ungroup() |> 
    arrange(Number) |> #Arranging the samples by the categories you wish to arrange by
    select(OTU, Number, OccThresh) |> #Selects the chosen columns
    pivot_wider(names_from = "Number", 
                values_from = "OccThresh") #Reshapes from long to wide format, with 'Sample' = column name and 'OccThresh' = filling values with this
  
  spp <- thresh_tbl$OTU #Extracts the OTU column and stores into a new variable called spp
  
  thresh_mat <- thresh_tbl |> 
    select(-OTU) |> #Selects all columns except for the OTU column
    as.matrix()
  rownames(thresh_mat) <- spp #This assigns the spp vector as row names to the thresh_mat matrix
  
  ## Zero things
  tab <- otu_table(ps_filt) #takes out OTU table from filtered phyloseq and stores it into tab
  tab[tab < thresh_mat] <- 0 #This sets any values in the OTU table which are less than thresh_mat to 0 
  
  otu_table(ps_filt) <- tab # This assigns the modified OTU table back to the phyloseq object
  
  ps_filt
}
```

```{r}
library(brms)
library(dplyr)
library(parallel)
library(tidyr)
library(phyloseq)

ps <- ps_minimum_P3

colprods <- estimate_colprods(ps) #Calls function estimate_colprods and applies is to the phyloseq object


#Building a Bayesian Regression Model from the brms package - 
thresholds_mod <- brm(formula = bf(Abundance ~ 0 + Intercept + fr_scale + (1 + fr_scale | OTU),
                                          shape ~ 0 + Intercept + (1 | OTU)),
                             family = negbinomial(),
                             prior = c(set_prior("normal(0, 3)", class = "b"),
                                       set_prior("exponential(2)", class = "sd"),
                                       set_prior("lkj(3)", class = "cor")),
                             data = dplyr::filter(colprods, 
                                                  SampleType == "unused"),
                             chains = 4,
                             cores = 1,
                             threads = threading(16),
                             silent = 0
               )
			   


saveRDS(colprods, file.path(output,"Colprods_P3.RDS"))

saveRDS(thresholds_mod, file.path(output,"Thresholds_mod_P3.RDS"))



colprods <- readRDS(file.path(output,"Colprods_P3.RDS"))

thresholds_mod <- readRDS(file.path(output,"Thresholds_mod_P3.RDS"))


ps_long_data <- colprods |>
	filter(SampleType == "Sample") |> #filters to keep only the data points where SampleType is equal to Sample
	nest_by(OTU, .keep = TRUE) |> #Group the filtered dataset by OTU
	mutate(Pred = list(posterior_predict(thresholds_mod, newdata = data)), 
		Quant = list(apply(Pred, 2, \(x) quantile(x, 0.975) |> round())),
		data = list(bind_cols(data, OccThresh = Quant) |> select(-OTU))
	) |>
	select(-Pred, -Quant) |>
	unnest(cols = c(data))
	

ps_corrected_P3 <- ps_correct_tj(ps_minimum_P3, ps_long_data)
 

saveRDS(ps_corrected_P3, "F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Tag_Jumping\\ps_corrected_P3.RDS")
```

#Loading tag corrected files
```{r}
ps_1_tj <-readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Tag_Jumping\\ps_corrected_P1.RDS")
 
ps_2_tj <-readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Tag_Jumping\\ps_corrected_P2.RDS")

ps_3_tj <-readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Tag_Jumping\\ps_corrected_P3.RDS")

ps_4_tj <-readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Tag_Jumping\\ps_corrected_P4.RDS")

ps_merged <- merge_phyloseq(ps_1_tj, ps_2_tj, ps_3_tj, ps_4_tj)

saveRDS(ps_merged, "F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Tag_Jumping\\merged_no_decontam.RDS")
```

#Running decontam package on individual pools
```{r}
library(decontam)

####cleaning data for Pool 1:
#Extracting metadata
ps_1_tj_sample_data <- as.data.frame(sample_data(ps_1_tj)) # Put sample_data into a ggplot-friendly data.frame

#Adding column for decontam package - for negative controls and true samples
ps_1_tj_sample_data$Sample_or_control <- ifelse(grepl("Neg", ps_1_tj_sample_data$Sample.ID), "Control", "Sample")

#Overwriting the old Metadata in the phyloseq object with the Metadata with sample_or_control
sample_data(ps_1_tj) <- sample_data(ps_1_tj_sample_data)

metadata_extract <- as.data.frame(sample_data(ps_1_tj))

#Identifying true samples vs controls in a plot
df_1 <- as.data.frame(sample_data(ps_1_tj)) # Put sample_data into a ggplot-friendly d
df_1$LibrarySize <- sample_sums(ps_1_tj)
df_1 <- df_1[order(df_1$LibrarySize),]
df_1$Index <- seq(nrow(df_1))

plot <- ggplot(data=df_1, aes(x=Index, y=LibrarySize, color=Sample_or_control)) + 
  geom_point(size=4) +  # Increase point size
  theme(
    axis.title = element_text(size=16),  # Axis title font size
    axis.text = element_text(size=14),   # Axis label font size
    plot.title = element_text(size=18),  # Plot title font size
    legend.text = element_text(size=14), # Legend text font size
    legend.title = element_text(size=16) # Legend title font size
  ) +
  labs(title = "16S - Pool 1 - Neg controls and true samples")  # Add a title (optional)

ggsave("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Images\\neg_16S_pool1.png", plot, width = 10, height = 8, bg = "white", dpi = 300)

#cleaning data via frequency and prevalence for pool 1
sample_data(ps_1_tj)$is.neg <- sample_data(ps_1_tj)$Sample_or_control == "Control"

#filtering by extraction batch
contamdf.freq_ps_1_tj <- isContaminant(ps_1_tj, method="combined", conc="DNA_Concentration_16S", neg = "is.neg", batch = "Extraction.Batch",)

table(contamdf.freq_ps_1_tj$contaminant)
#This identified 549  ASV which were contaminants and 3602 true samples

ps_1_tj_no_extr_neg <- prune_taxa(!contamdf.freq_ps_1_tj$contaminant, ps_1_tj)
ps_1_tj_no_extr_neg

#filtering by PCR negative controls
contamdf.ps_1_tj_no_extr_neg <- isContaminant(ps_1_tj_no_extr_neg, method="combined", conc="DNA_Concentration_16S", neg = "is.neg", batch = "PCR.Plate",)

table(contamdf.ps_1_tj_no_extr_neg$contaminant)
#This identified 134  ASV which were contaminants and 3468 true samples

ps_1_tj_decontam <- prune_taxa(!contamdf.ps_1_tj_no_extr_neg$contaminant, ps_1_tj_no_extr_neg)

ps_1_tj_decontam

#Cleaning data for pool 2: 
#Extracting metadata
ps_2_tj_sample_data <- as.data.frame(sample_data(ps_2_tj)) # Put sample_data into a ggplot-friendly data.frame

#Adding column for decontam package - for negative controls and true samples
ps_2_tj_sample_data$Sample_or_control <- ifelse(grepl("Neg", ps_2_tj_sample_data$Sample.ID), "Control", "Sample")

#Overwriting the old Metadata in the phyloseq object with the Metadata with sample_or_control
sample_data(ps_2_tj) <- sample_data(ps_2_tj_sample_data)


#Identifying true samples vs controls in a plot
df_2 <- as.data.frame(sample_data(ps_2_tj)) # Put sample_data into a ggplot-friendly d
df_2$LibrarySize <- sample_sums(ps_2_tj)
df_2 <- df_2[order(df_2$LibrarySize),]
df_2$Index <- seq(nrow(df_2))

plot <- ggplot(data=df_2, aes(x=Index, y=LibrarySize, color=Sample_or_control)) + 
  geom_point(size=4) +  # Increase point size
  theme(
    axis.title = element_text(size=16),  # Axis title font size
    axis.text = element_text(size=14),   # Axis label font size
    plot.title = element_text(size=18),  # Plot title font size
    legend.text = element_text(size=14), # Legend text font size
    legend.title = element_text(size=16) # Legend title font size
  ) +
  labs(title = "16S - Pool 2 - Neg controls and true samples")  # Add a title (optional)

ggsave("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Images\\neg_16S_pool2.png", plot, width = 10, height = 8, bg = "white", dpi = 300)

#some numbers were missing from extraction batches, adding them in: 
metadata_extract <- as.data.frame(sample_data(ps_2_tj))

sample_data(ps_2_tj)$Extraction.Batch <- ifelse(
  sample_data(ps_2_tj)$Extraction.Batch == "" | is.na(sample_data(ps_2_tj)$Extraction.Batch),
  substr(sample_data(ps_2_tj)$Sample.ID, nchar(sample_data(ps_2_tj)$Sample.ID)-1, nchar(sample_data(ps_2_tj)$Sample.ID)),
  sample_data(ps_2_tj)$Extraction.Batch
)

#cleaning data via frequency and prevalence for pool 2
sample_data(ps_2_tj)$is.neg <- sample_data(ps_2_tj)$Sample_or_control == "Control"

#filtering by extraction batch
contamdf.freq_ps_2_tj <- isContaminant(ps_2_tj, method="combined", conc="DNA_Concentration_16S", neg = "is.neg", batch = "Extraction.Batch")

table(contamdf.freq_ps_2_tj$contaminant)
#This identified 549  ASV which were contaminants and 3602 true samples

ps_2_tj_no_extr_neg <- prune_taxa(!contamdf.freq_ps_2_tj$contaminant, ps_2_tj)
ps_2_tj_no_extr_neg

#filtering by PCR negative controls
contamdf.ps_2_tj_no_extr_neg <- isContaminant(ps_2_tj_no_extr_neg, method="combined", conc="DNA_Concentration_16S", neg = "is.neg", batch = "PCR.Plate",)

table(contamdf.ps_2_tj_no_extr_neg$contaminant)
#This identified 134  ASV which were contaminants and 3468 true samples

ps_2_tj_decontam <- prune_taxa(!contamdf.ps_2_tj_no_extr_neg$contaminant, ps_2_tj_no_extr_neg)

ps_2_tj_decontam

#Cleaning pool 3
#Extracting metadata
ps_3_tj_sample_data <- as.data.frame(sample_data(ps_3_tj)) # Put sample_data into a ggplot-friendly data.frame

#Adding column for decontam package - for negative controls and true samples
ps_3_tj_sample_data$Sample_or_control <- ifelse(grepl("Neg", ps_3_tj_sample_data$Sample.ID), "Control", "Sample")

#Overwriting the old Metadata in the phyloseq object with the Metadata with sample_or_control
sample_data(ps_3_tj) <- sample_data(ps_3_tj_sample_data)

#Identifying true samples vs controls in a plot
df_3 <- as.data.frame(sample_data(ps_3_tj)) # Put sample_data into a ggplot-friendly d
df_3$LibrarySize <- sample_sums(ps_3_tj)
df_3 <- df_3[order(df_3$LibrarySize),]
df_3$Index <- seq(nrow(df_3))

plot <- ggplot(data=df_3, aes(x=Index, y=LibrarySize, color=Sample_or_control)) + 
  geom_point(size=4) +  # Increase point size
  theme(
    axis.title = element_text(size=16),  # Axis title font size
    axis.text = element_text(size=14),   # Axis label font size
    plot.title = element_text(size=18),  # Plot title font size
    legend.text = element_text(size=14), # Legend text font size
    legend.title = element_text(size=16) # Legend title font size
  ) +
  labs(title = "16S - Pool 3 - Neg controls and true samples")  # Add a title (optional)

ggsave("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Images\\neg_16S_pool3.png", plot, width = 10, height = 8, bg = "white", dpi = 300)

#some numbers were missing from extraction batches, adding them in: 
metadata_extract <- as.data.frame(sample_data(ps_3_tj))

# Update Extraction.Batch for the specific sample
# Access sample data
sample_data <- sample_data(ps_3_tj)
sample_data[sample_data$Sample.ID == "P3_PO_Zymo_Control_Soil", "Extraction.Batch"] <- 43
# Save updated sample data back to the phyloseq object
sample_data(ps_3_tj) <- sample_data


#adding the last two characters from Sample.ID to Extraction.Batch
# Access sample data
sample_data <- sample_data(ps_3_tj)
# Identify samples containing "Extraction_Neg" in the Sample.ID
neg_samples <- grepl("Extraction_Neg", sample_data$Sample.ID)
# Extract the last two characters from Sample.ID and update Extraction.Batch
sample_data$Extraction.Batch[neg_samples] <- substr(sample_data$Sample.ID[neg_samples], 
                                                    nchar(sample_data$Sample.ID[neg_samples]) - 1, 
                                                    nchar(sample_data$Sample.ID[neg_samples]))

# Save updated sample data back to the phyloseq object
sample_data(ps_3_tj) <- sample_data

#adding N/A to extraction.batch for neg_pcr samples
sample_data <- sample_data(ps_3_tj)
sample_data$Extraction.Batch[grepl("PCR_Neg", sample_data$Sample.ID)] <- "N/A"
sample_data(ps_3_tj) <- sample_data

#Remove batch 34 as only 2 samples and cannot be used in decontam batch
# Store removed samples in a separate phyloseq object
ps_3_tj_removed <- subset_samples(ps_3_tj, Extraction.Batch == 34)

# Remove rows where Extraction.Batch is 34
ps_3_tj <- subset_samples(ps_3_tj, Extraction.Batch != 34)

#cleaning data via frequency and prevalence for pool 3
sample_data(ps_3_tj)$is.neg <- sample_data(ps_3_tj)$Sample_or_control == "Control"

#filtering by extraction batch
contamdf.freq_ps_3_tj <- isContaminant(ps_3_tj, method="combined", conc="DNA_Concentration_16S", neg = "is.neg", batch = "Extraction.Batch")

table(contamdf.freq_ps_3_tj$contaminant)
#This identified 549  ASV which were contaminants and 3602 true samples

ps_3_tj_no_extr_neg <- prune_taxa(!contamdf.freq_ps_3_tj$contaminant, ps_3_tj)
ps_3_tj_no_extr_neg

#filtering by PCR negative controls
contamdf.ps_3_tj_no_extr_neg <- isContaminant(ps_3_tj_no_extr_neg, method="combined", conc="DNA_Concentration_16S", neg = "is.neg", batch = "PCR.Plate",)

table(contamdf.ps_3_tj_no_extr_neg$contaminant)
#This identified 134  ASV which were contaminants and 3468 true samples

ps_3_tj_decontam <- prune_taxa(!contamdf.ps_3_tj_no_extr_neg$contaminant, ps_3_tj_no_extr_neg)

#add back batch 34 into phyloseq object
ps_3_tj_decontam <- merge_phyloseq(ps_3_tj_decontam, ps_3_tj_removed)

ps_3_tj_decontam

#Cleaning pool 4
#Extracting metadata
ps_4_tj_sample_data <- as.data.frame(sample_data(ps_4_tj)) # Put sample_data into a ggplot-friendly data.frame

#Adding column for decontam package - for negative controls and true samples
ps_4_tj_sample_data$Sample_or_control <- ifelse(grepl("Neg", ps_4_tj_sample_data$Sample.ID), "Control", "Sample")

#Overwriting the old Metadata in the phyloseq object with the Metadata with sample_or_control
sample_data(ps_4_tj) <- sample_data(ps_4_tj_sample_data)

#Identifying true samples vs controls in a plot
df_4 <- as.data.frame(sample_data(ps_4_tj)) # Put sample_data into a ggplot-friendly d
df_4$LibrarySize <- sample_sums(ps_4_tj)
df_4 <- df_4[order(df_4$LibrarySize),]
df_4$Index <- seq(nrow(df_4))

plot <- ggplot(data=df_4, aes(x=Index, y=LibrarySize, color=Sample_or_control)) + 
  geom_point(size=4) +  # Increase point size
  theme(
    axis.title = element_text(size=16),  # Axis title font size
    axis.text = element_text(size=14),   # Axis label font size
    plot.title = element_text(size=18),  # Plot title font size
    legend.text = element_text(size=14), # Legend text font size
    legend.title = element_text(size=16) # Legend title font size
  ) +
  labs(title = "16S - Pool 4 - Neg controls and true samples")  # Add a title (optional)

ggsave("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Images\\neg_16S_pool4.png", plot, width = 10, height = 8, bg = "white", dpi = 300)

#cleaning data via frequency method
contamdf.freq_ps_4_tj <- isContaminant(ps_4_tj, method="frequency", conc="DNA_Concentration_16S")
head(contamdf.freq_ps_4_tj)

table(contamdf.freq_ps_4_tj$contaminant)
#This identified 38 ASV which were contaminants and 3813 true samples

ps_4_tj_no_contam <- prune_taxa(!contamdf.freq_ps_4_tj$contaminant, ps_4_tj)
ps_4_tj_no_contam

#Combine decontam phyloseq object
ps_merged <- merge_phyloseq(ps_1_tj_decontam, ps_2_tj_decontam, ps_3_tj_decontam, ps_4_tj_no_contam)

#removing Archaea before saving
ps_merged <- subset_taxa(ps_merged, Kingdom != "Archaea")

saveRDS(ps_merged, file = "F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Tag_Jumping\\ps_merged_decontam.RDS")
```

#Calculating the number of read loss from filtering steps
```{r}
#Counts from raw sequences

#Pool 1_L2
file_path <- "D:\\PhD_Bioinformatics\\1BIG_EXPERIMENT\\16S_Pool_1\\Raw_Sequences\\UH_16S_P1_FKDN240093188-1A_H2CGNDRX5_L2_1.fq.gz"

# Open the compressed file
con <- gzfile(file_path, "r")

# Initialize line counter
line_count <- 0

# Read the file line by line and count lines
while (length(line <- readLines(con, n = 1000)) > 0) {
  line_count <- line_count + length(line)
}

# Close the connection
close(con)

# Print the total number of lines
print(line_count)

# line count was 163673932

Reads_16S_1_L1 <- 163673932/4


#Pool 2_L2
file_path <- "D:\\PhD_Bioinformatics\\1BIG_EXPERIMENT\\16S_Pool_2\\Raw_Sequences\\UH_16S_P2_FKDN240093189-1A_H2CGNDRX5_L2_1.fq.gz"

# Open the compressed file
con <- gzfile(file_path, "r")

# Initialize line counter
line_count <- 0

# Read the file line by line and count lines
while (length(line <- readLines(con, n = 1000)) > 0) {
  line_count <- line_count + length(line)
}

# Close the connection
close(con)

# Print the total number of lines
print(line_count)

# line count was 111723440

Reads_16S_2 <- 111723440/4


#Pool 3 L2
file_path <- "D:\\PhD_Bioinformatics\\1BIG_EXPERIMENT\\16S_Pool_3\\Raw_Sequences\\UH_16S_P3_FKDN240093190-1A_H2CGNDRX5_L2_1.fq.gz"

# Open the compressed file
con <- gzfile(file_path, "r")

# Initialize line counter
line_count <- 0

# Read the file line by line and count lines
while (length(line <- readLines(con, n = 1000)) > 0) {
  line_count <- line_count + length(line)
}

# Close the connection
close(con)

# Print the total number of lines
print(line_count)

# line count was 133770172

Reads_16S_3 <- 133770172/4


#Pool 4
file_path <- "D:\\PhD_Bioinformatics\\1BIG_EXPERIMENT\\16S_Pool_4\\Raw_Sequences\\UH_16S_P4_FKDN240093191-1A_H27G7DRX5_L2_1.fq.gz"

# Open the compressed file
con <- gzfile(file_path, "r")

# Initialize line counter
line_count <- 0

# Read the file line by line and count lines
while (length(line <- readLines(con, n = 1000)) > 0) {
  line_count <- line_count + length(line)
}

# Close the connection
close(con)

# Print the total number of lines
print(line_count)

# line count was 89713620

Reads_16S_4 <- 89713620/4


#reads for pool 1 = 40918483
#reads for pool 2 = 27930860
#reads for pool 3 = 33442543
#reads for pool 4 = 22428405

combined_reads <- 40918483 + 27930860 + 33442543 + 22428405

#combined reads for all pools = 124720291


###Checking de-multiplexed samples

#checking reads only in R1
# Specify the directory containing the .fq.gz files
dir_path <- "F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Raw_Sequences\\16S_Sequences\\"

# Get a list of all .fq.gz files in the directory
files <- list.files(path = dir_path, pattern = "R1\\.fastq.gz$", full.names = TRUE)

# Initialize total line counter
total_line_count <- 0

# Loop through each file and count the lines
for (file_path in files) {
  # Open the compressed file
  con <- gzfile(file_path, "r")
  
  # Initialize line counter for the current file
  line_count <- 0
  
  # Read the file line by line and count lines
  while (length(line <- readLines(con, n = 1000)) > 0) {
    line_count <- line_count + length(line)
  }
  
  # Close the connection
  close(con)
  
  # Add the line count of the current file to the total line count
  total_line_count <- total_line_count + line_count
  
  # Print the line count for the current file (optional)
  cat("File:", file_path, "has", line_count, "lines\n")
}

# Print the total number of lines across all files
cat("Total number of lines across all files:", total_line_count, "\n")

cat("Total number of reads across all files:", total_line_count/4, "\n")

#total number of lines = 422120116   
#total number of reads = 105530029 


#checking reads from files with primers cut
# Specify the directory containing the .fq.gz files
dir_path <- "D:\\PhD_Bioinformatics\\1BIG_EXPERIMENT\\16S_All\\Processed_Sequences\\16S\\no_primers\\"

# Get a list of all .fq.gz files in the directory
files <- list.files(path = dir_path, pattern = "R1\\.fastq.gz$", full.names = TRUE)

# Initialize total line counter
total_line_count <- 0

# Loop through each file and count the lines
for (file_path in files) {
  # Open the compressed file
  con <- gzfile(file_path, "r")
  
  # Initialize line counter for the current file
  line_count <- 0
  
  # Read the file line by line and count lines
  while (length(line <- readLines(con, n = 1000)) > 0) {
    line_count <- line_count + length(line)
  }
  
  # Close the connection
  close(con)
  
  # Add the line count of the current file to the total line count
  total_line_count <- total_line_count + line_count
  
  # Print the line count for the current file (optional)
  cat("File:", file_path, "has", line_count, "lines\n")
}

# Print the total number of lines across all files
cat("Total number of lines across all files:", total_line_count, "\n")

#Print the number of reads 
cat("Total number of reads across all files:", total_line_count/4, "\n")


#total number of lines = 422120116   
#total number of reads = 105530029


#checking reads from files with primers cut and filtered

# Specify the directory containing the .fq.gz files
dir_path <- "F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Processed_Sequences\\16S\\no_primers\\filtered\\"

# Get a list of all .fq.gz files in the directory
files <- list.files(path = dir_path, pattern = "R1\\.fastq.gz$", full.names = TRUE)

# Initialize total line counter
total_line_count <- 0

# Loop through each file and count the lines
for (file_path in files) {
  # Open the compressed file
  con <- gzfile(file_path, "r")
  
  # Initialize line counter for the current file
  line_count <- 0
  
  # Read the file line by line and count lines
  while (length(line <- readLines(con, n = 1000)) > 0) {
    line_count <- line_count + length(line)
  }
  
  # Close the connection
  close(con)
  
  # Add the line count of the current file to the total line count
  total_line_count <- total_line_count + line_count
  
  # Print the line count for the current file (optional)
  cat("File:", file_path, "has", line_count, "lines\n")
}

# Print the total number of lines across all files
cat("Total number of lines across all files:", total_line_count, "\n")

#Print the number of reads 
cat("Total number of reads across all files:", total_line_count/4, "\n")

#number of lines = 379984232   
#number of reads = 94996058  


#checking number of reads after applying ASV sample inference algorithm
getN <- function(x) sum(getUniques(x))
dadaR1_reads <- sum(sapply(readRDS(file.path(output,"dadaR1_16S.RDS")), getN))

# Print the number of reads
cat("Number of reads in dadaR1 (FORWARD reads):", dadaR1_reads, "\n")

#number of reads after applying sample inference algorithm = 92449325


###calculating number of reads lost from merging
merged_reads <- sum(sapply(readRDS(file.path(output,"mergers_16S.RDS")), getN))
#Reads after merging = 83642308

##Checking number of reads after filtering with read length
Filter_length <- sum(readRDS(file.path(output, "seqtab_noShort_16S.RDS")))
#Reads after filtering = 83502857

##Checking number of reads after removing chimeras
Removing_chimeras <- sum(readRDS(file.path(output, "seqtab_nochim_16S.RDS")))
#Reads after removing chimeras = 81340428


##checking number of reads after assigning taxonomy = same as removing chimeras


##Checking number of reads after removing chloroplast and mitochondria reads
ps_merged <- readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Processed_Sequences\\Phyloseq_without_plastid.RDS")


otu_table_filtered <- otu_table(ps_merged)

otu_matrix_filtered <- as.matrix(otu_table_filtered)

total_reads_filtered <- sum(otu_matrix_filtered)

print(total_reads_filtered)

#Reads after removing chloroplast and mitochondria = 37515211


#Reads after filtering by a minimum of 150 
ps_merged <- readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Processed_Sequences\\Phyloseq_without_plastid_100.RDS")

otu_table_filtered <- otu_table(ps_merged)

otu_matrix_filtered <- as.matrix(otu_table_filtered)

total_reads_filtered <- sum(otu_matrix_filtered)

print(total_reads_filtered)

#Number of reads after filtering = 34162348

##Number of reads after tag_jumping
ps_1_tj <-readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Tag_Jumping\\ps_corrected_P1.RDS")

ps_2_tj <-readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Tag_Jumping\\ps_corrected_P2.RDS")

ps_3_tj <-readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Tag_Jumping\\ps_corrected_P3.RDS")

ps_4_tj <-readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Tag_Jumping\\ps_corrected_P4.RDS")

#Extract ASV Table
ps_1_tj_ASV_table <- as.data.frame(otu_table(ps_1_tj))
ps_2_tj_ASV_table <- as.data.frame(otu_table(ps_2_tj))
ps_3_tj_ASV_table <- as.data.frame(otu_table(ps_3_tj))
ps_4_tj_ASV_table <- as.data.frame(otu_table(ps_4_tj))

#Calculating number of reads from each ASV_Table
total_reads_P1_tj <- sum(ps_1_tj_ASV_table)
total_reads_P2_tj <- sum(ps_2_tj_ASV_table)
total_reads_P3_tj <- sum(ps_3_tj_ASV_table)
total_reads_P4_tj <- sum(ps_4_tj_ASV_table)

#Printing number of reads
cat("Total number of reads P1_tj:", total_reads_P1_tj, "\n")
cat("Total number of reads P2_tj:", total_reads_P2_tj, "\n")
cat("Total number of reads P3_tj:", total_reads_P3_tj, "\n")
cat("Total number of reads P4_tj:", total_reads_P4_tj, "\n")
cat("Total reads from all:", total_reads_P1_tj + total_reads_P2_tj + total_reads_P3_tj + total_reads_P4_tj, "\n")

#Total number of reads P1_tj: 11487449  
#Total number of reads P2_tj: 4891445  
#Total number of reads P3_tj: 6695356  
#Total number of reads P4_tj: 3099808
#Total reads from all: 26174058

#Checking number of reads after decontam package
ps_merged <- readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Tag_Jumping\\ps_merged_decontam.RDS")

#Extract ASV Table
ps_merged_ASV_table <- as.data.frame(otu_table(ps_merged))

#Calculating number of reads from decontam ASV table
total_reads_ps_merged <- sum(ps_merged_ASV_table)
cat("Total number of reads ps_merged:", total_reads_ps_merged, "\n")
#Total after decontam: 21909548
```

#Summary of read loss through filtering steps
```{r}
# Number of sequences before demultiplexing
Raw_Reads <- 124720291
Demultiplexed <- 105530029
Filtered <- 94996058
Infer_ASVs <- 92449325
Merged_reads <- 83642308
Filtered_by_length <- 83502857
Removed_Chimeras <- 81340428
Assign_taxonomy <- 81340428
Removing_plastid <- 37515211
Filtering_150_reads <- 34162348
Tag_Jumping <- 26174058
Decontam <- 21909548

# Create the data frame with the updated data
track_df <- data.frame(
  Step = c("Raw_Reads", "Demultiplexed", "Filtered", 
           "Infer_ASVs", "Merged_reads", "Filtered_by_length", 
           "Removed_Chimeras", "Assign_taxonomy", 
           "Removing_plastid", "Filtering_150_reads", "Tag_Jumping", "Decontam"),
  Reads = c(Raw_Reads, Demultiplexed, Filtered, Infer_ASVs, Merged_reads, 
            Filtered_by_length, Removed_Chimeras, Assign_taxonomy, 
            Removing_plastid, Filtering_150_reads, Tag_Jumping, Decontam)
)

# Reorder Step as a factor in the desired order
track_df$Step <- factor(track_df$Step, levels = track_df$Step)

# Plotting with ggplot2
plot <- ggplot(track_df, aes(x = Step, y = Reads)) +
  geom_line(group = 1, color = "blue") +
  geom_point(size = 4, shape = 21, fill = "lightblue", color = "blue") +
  geom_text(aes(label = Reads),
            angle = 0,
            hjust = 0.5, # Center the text horizontally
            vjust = ifelse(1:nrow(track_df) %% 2 == 1, -0.5, 1.5), # Alternate vjust
            size = 6) +  # Increase text size
  labs(
    title = NULL,
    x = NULL,
    y = "Number of Reads"
  ) +
  theme_minimal(base_size = 15) +
  theme(
    axis.title.x = element_text(size = 18, face = "bold", color = "black"), # Make x-axis title bold and set color to black
    axis.title.y = element_text(size = 18, face = "bold", color = "black"), # Make y-axis title bold and set color to black
    axis.text.x = element_text(angle = 45, hjust = 1, size = 15, color = "black"), # Adjust x-axis label font size and set color to black
    axis.text.y = element_text(size = 18, color = "black"), # Adjust y-axis label font size and set color to black
    plot.background = element_rect(color = "white")
  )

# Display the plot
print(plot)

# Save the plot
ggsave("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Images\\read_loss_bacteria.png", plot, width = 15, height = 10)
```

#Making graphs and calculating stats from sequencing data -----------------------------------------
#Loading packages 
```{r}
library(tidyr)
library(dada2)
library(seqinr)
library(stringr)
library(writexl)
library(microbiome)
library(dplyr)
library(ShortRead)
library(vegan)
library(ggplot2)
library(ggsignif)
library(vegan)
library(dada2)
library(tidyr)
library(broom)
library(rstatix)
library(ggpubr)
library(metacoder)
library(patchwork)
library(cowplot)
library(reshape2)
```

#Loading phyloseq objects
```{r}
# Load the filtered phyloseq object
ps_16S <- readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Tag_Jumping\\ps_merged_decontam.RDS")

ps_ITS <- readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\ITS_All\\Tag_Jumping\\ps_merged_decontam.RDS")

```

#Calculating number of reads
```{r}
# Calculate average and median reads per sample for 16S
avg_reads_16S <- mean(sample_sums(ps_16S))
median_reads_16S <- median(sample_sums(ps_16S))

# Calculate average and median reads per sample for ITS
avg_reads_ITS <- mean(sample_sums(ps_ITS))
median_reads_ITS <- median(sample_sums(ps_ITS))

# Print the results
cat("16S Average Reads per Sample:", avg_reads_16S, "\n")
cat("16S Median Reads per Sample:", median_reads_16S, "\n")
cat("ITS Average Reads per Sample:", avg_reads_ITS, "\n")
cat("ITS Median Reads per Sample:", median_reads_ITS, "\n")

# Calculate total reads per dataset
total_reads_16S <- sum(sample_sums(ps_16S))
total_reads_ITS <- sum(sample_sums(ps_ITS))

# Print results
cat("Total Reads for 16S:", total_reads_16S, "\n")
cat("Total Reads for ITS:", total_reads_ITS, "\n")
```

#Filtering phyloseq objects with pathology data - 16S
```{r}
# Load phyloseq object
ps_16S <- readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Tag_Jumping\\ps_merged_decontam.RDS")

# Load pathology data
pathology_df <- read.csv("D:\\PhD_Bioinformatics\\1BIG_EXPERIMENT\\16S_All\\Processed_Sequences\\Pathology_Data_Simplified_Option_2.csv")

#Count how many trees with AOD
table(pathology_df$AOD)

#count how many AOD within each biotic
counts <- table(pathology_df$Pathology_Treatment, pathology_df$AOD)

# Add "T" to Tree_No. in pathology_df and rename to Tree.Number
pathology_df$Tree_No. <- paste0("T", pathology_df$Tree_No.)
colnames(pathology_df)[colnames(pathology_df) == "Tree_No."] <- "Tree.Number"

# Ensure Tree.Number columns are character for consistency
pathology_df$Tree.Number <- as.character(pathology_df$Tree.Number)
sample_data(ps_16S)$Tree.Number <- as.character(sample_data(ps_16S)$Tree.Number)

# Create a lookup table from Tree.Number to Pathology_Treatment
lookup_treatment <- setNames(pathology_df$Pathology_Treatment, pathology_df$Tree.Number)

# Update Biotic column only for matching Tree.Number values
matching_indices <- which(sample_data(ps_16S)$Tree.Number %in% names(lookup_treatment))

# Update only the matching rows in the Biotic column
sample_data(ps_16S)$Biotic[matching_indices] <- 
  lookup_treatment[sample_data(ps_16S)$Tree.Number[matching_indices]]

#check metadata
check_metadata <- as.data.frame(sample_data(ps_16S))

#Adding the AOD column 
# Create a lookup table for AOD based on Tree.Number in pathology_df
lookup_AOD <- setNames(pathology_df$AOD, pathology_df$Tree.Number)

# Ensure the Tree.Number columns are characters (if not already)
pathology_df$Tree.Number <- as.character(pathology_df$Tree.Number)
sample_data(ps_16S)$Tree.Number <- as.character(sample_data(ps_16S)$Tree.Number)

# Find the indices of matching Tree.Number values
matching_indices_AOD <- which(sample_data(ps_16S)$Tree.Number %in% names(lookup_AOD))

# Add the AOD column to sample data if it doesn't exist
if(!"AOD" %in% colnames(sample_data(ps_16S))) {
  sample_data(ps_16S)$AOD <- NA
}

# Update the AOD column with the corresponding values
sample_data(ps_16S)$AOD[matching_indices_AOD] <- 
  lookup_AOD[sample_data(ps_16S)$Tree.Number[matching_indices_AOD]]

#check metadata
check_metadata_16S <- as.data.frame(sample_data(ps_16S))
```

#Filtering phyloseq objects with pathology data - ITS
```{r}
# Load phyloseq object
ps_ITS <- readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\ITS_All\\Tag_Jumping\\ps_merged_decontam.RDS")

# Load pathology data
pathology_df <- read.csv("D:\\PhD_Bioinformatics\\1BIG_EXPERIMENT\\16S_All\\Processed_Sequences\\Pathology_Data_Simplified_Option_2.csv")

#Count how many trees with AOD
table(pathology_df$AOD)

#count how many AOD within each biotic
counts <- table(pathology_df$Pathology_Treatment, pathology_df$AOD)

# Add "T" to Tree_No. in pathology_df and rename to Tree.Number
pathology_df$Tree_No. <- paste0("T", pathology_df$Tree_No.)
colnames(pathology_df)[colnames(pathology_df) == "Tree_No."] <- "Tree.Number"

# Ensure Tree.Number columns are character for consistency
pathology_df$Tree.Number <- as.character(pathology_df$Tree.Number)
sample_data(ps_ITS)$Tree.Number <- as.character(sample_data(ps_ITS)$Tree.Number)

# Create a lookup table from Tree.Number to Pathology_Treatment
lookup_treatment <- setNames(pathology_df$Pathology_Treatment, pathology_df$Tree.Number)

# Update Biotic column only for matching Tree.Number values
matching_indices <- which(sample_data(ps_ITS)$Tree.Number %in% names(lookup_treatment))

# Update only the matching rows in the Biotic column
sample_data(ps_ITS)$Biotic[matching_indices] <- 
  lookup_treatment[sample_data(ps_ITS)$Tree.Number[matching_indices]]

#check metadata
check_metadata <- as.data.frame(sample_data(ps_ITS))

#Adding the AOD column 
# Create a lookup table for AOD based on Tree.Number in pathology_df
lookup_AOD <- setNames(pathology_df$AOD, pathology_df$Tree.Number)

# Ensure the Tree.Number columns are characters (if not already)
pathology_df$Tree.Number <- as.character(pathology_df$Tree.Number)
sample_data(ps_ITS)$Tree.Number <- as.character(sample_data(ps_ITS)$Tree.Number)

# Find the indices of matching Tree.Number values
matching_indices_AOD <- which(sample_data(ps_ITS)$Tree.Number %in% names(lookup_AOD))

# Add the AOD column to sample data if it doesn't exist
if(!"AOD" %in% colnames(sample_data(ps_ITS))) {
  sample_data(ps_ITS)$AOD <- NA
}

# Update the AOD column with the corresponding values
sample_data(ps_ITS)$AOD[matching_indices_AOD] <- 
  lookup_AOD[sample_data(ps_ITS)$Tree.Number[matching_indices_AOD]]

#check metadata
check_metadata_ITS <- as.data.frame(sample_data(ps_ITS))
```

#filtering phyloseq objects for graphical and statistical analysis
```{r}
#16S
ps_AOD_16S <- ps_16S
# Prune samples with fewer than 20 reads
ps_AOD_16S <- prune_samples(sample_sums(ps_AOD_16S) >= 20, ps_AOD_16S)

# Remove negative controls, zymos, and mPNA clamp test
ps_AOD_16S <- microViz::ps_filter(ps_AOD_16S, !grepl("Neg|Zymo|mPNA|Ale", Sample.ID))

# Remove samples where AOD column contains "DEAD"
ps_AOD_16S <- subset_samples(ps_AOD_16S, !grepl("DEAD", sample_data(ps_AOD_16S)$AOD))

saveRDS(ps_AOD_16S, "F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Tag_Jumping\\ps_AOD_16S_filtered.RDS")

#ITS
ps_AOD_ITS <- ps_ITS
# Prune samples with fewer than 20 reads
ps_AOD_ITS <- prune_samples(sample_sums(ps_AOD_ITS) >= 20, ps_AOD_ITS)

# Remove negative controls, zymos, and mPNA clamp test
ps_AOD_ITS <- microViz::ps_filter(ps_AOD_ITS, !grepl("Neg|Zymo|mPNA|Ale", Sample.ID))

# Remove samples where AOD column contains "DEAD"
ps_AOD_ITS <- subset_samples(ps_AOD_ITS, !grepl("DEAD", sample_data(ps_AOD_ITS)$AOD))

saveRDS(ps_AOD_ITS, "F:\\Bioinformatics\\Big_Experiment_Attempt_2\\ITS_All\\Tag_Jumping\\ps_AOD_ITS_filtered.RDS")
```

#Removing extra characters in fungal analysis
```{r}
# Read in the phyloseq object
ps_ITS <- readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\ITS_All\\Tag_Jumping\\ps_AOD_ITS_filtered.RDS")

# Extract the taxonomy table
tax_table(ps_ITS) <- apply(tax_table(ps_ITS), 2, function(x) sub("^.{3}", "", x))

saveRDS(ps_ITS, "F:\\Bioinformatics\\Big_Experiment_Attempt_2\\ITS_All\\Tag_Jumping\\ps_AOD_ITS_filtered_k_removed.RDS")
```


#Loading and filtering phyloseq objects for graphing
```{r}
ps_16S <- readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Tag_Jumping\\ps_AOD_16S_filtered.RDS")

#removing samples out of bound in graphs
samples_to_remove <- c(
  "P2_PR_T333_B3_R_L", "P2_PR_T631_B6_R_L", "P2_PR_T324_B3_C_L", "P2_PR_T435_B4_R_L",
  "P2_PR_T434_B4_R_L", "P2_PR_T528_B5_C_L", "P2_PR_T135_B1_R_L", "P2_PR_T512_B5_D_L",
  "P2_PR_T427_B4_C_L", "P2_PR_T414_B4_D_L", "P2_PR_T217_B2_D_S", "P2_PR_T522_B5_C_S",
  "P2_PR_T636_B6_R_S", "P3_PR_T111_B1_D_R", "P3_PR_T313_B3_D_R", "P3_PR_T331_B3_R_R",
  "P3_PR_T128_B1_C_R", "P3_PR_T218_B2_D_R", "P3_PR_T315_B3_D_R", "P4_PR_T522_B5_C_L",
  "P2_PR_T124_B1_C_R", "P3_PO_T224_B2_C_S", "P4_LP_T528_B5_C_S", "P4_LP_T312_B3_D_S",
  "P2_BA_T424_B4_C_S", "P4_LP_T513_B5_D_S", "P1_BA_T521_B5_C_R", "P4_LP_T625_B6_C_L",
  "P1_BA_T625_B6_C_R", "P4_LP_T633_B6_R_S", "P1_BA_T114_B1_D_L", "P4_LP_T526_B5_C_S",
  "P4_LP_T517_B5_D_S", "P4_LP_T235_B2_R_S"
)

ps_16S <- microViz::ps_filter(ps_16S, !Sample.ID %in% samples_to_remove)

ps_ITS <- readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\ITS_All\\Tag_Jumping\\ps_AOD_ITS_filtered_k_removed.RDS")

# Remove negative controls, zymos, and mPNA clamp test
ps_ITS <- microViz::ps_filter(ps_ITS, !grepl("P2_PR_T211_B2_D_L", Sample.ID))

#Filtering out incertae sedis from fungi
# Convert taxonomy table to a dataframe
tax_df <- as.data.frame(tax_table(ps_ITS))

# Find rows where any column contains "Incertae_sedis"
taxa_to_remove <- rownames(tax_df)[apply(tax_df, 1, function(x) any(grepl("Incertae_sedis", x, ignore.case = TRUE)))]

# Remove those taxa from the phyloseq object
ps_ITS <- prune_taxa(!taxa_names(ps_ITS) %in% taxa_to_remove, ps_ITS)

check_tax <- as.data.frame(tax_table(ps_ITS))
```

#Filter by time point
```{r}
#Filtering for baseline (looking at control trees only, rain exclusion was not active at this point - so lumped in together with controls to increase statistical power)
ps_base_16S <- microViz::ps_filter(ps_16S, 
                                   grepl("BASE", Time) &
                                   Treatment %in% c("C", "D") &
                                   Organ %in% c("LEAF", "STEM", "ROOT"))

ps_base_ITS <- microViz::ps_filter(ps_ITS, 
                                   grepl("BASE", Time) &
                                   Treatment %in% c("C", "D") &
                                   Organ %in% c("LEAF", "STEM", "ROOT"))

#Filtering for second sampling time point
ps_3_month_16S <- microViz::ps_filter(ps_16S, 
                                   grepl("PRE", Time))

ps_3_month_ITS <- microViz::ps_filter(ps_ITS, 
                                   grepl("PRE", Time))

#Filtering for the third sampling time point 
ps_6_month_16S <- microViz::ps_filter(ps_16S, 
                              grepl("ROOT|LEAF|STEM", Organ) & 
                              grepl("\\bPOST\\b", Time))

ps_6_month_ITS <- microViz::ps_filter(ps_ITS, 
                              grepl("ROOT|LEAF|STEM", Organ) & 
                              grepl("\\bPOST\\b", Time))


#Filtering for the fourth sampling time point
ps_18_month_16S <- microViz::ps_filter(ps_16S, 
                              grepl("ROOT|LEAF|STEM", Organ) & 
                              grepl("\\bLPOST\\b", Time))

ps_18_month_ITS <- microViz::ps_filter(ps_ITS, 
                              grepl("ROOT|LEAF|STEM", Organ) & 
                              grepl("\\bLPOST\\b", Time))
```

Alpha diversity separating by tissues
#Alpha diversity - Time point 2 16S and ITS
``` {r}
#Repeating with only Stem: ------------------------

# Estimate Shannon diversity for Control (C), Rain Exclusion (D), and Ringbarked (R)
shannon_data_ps_3_month_16S <- estimate_richness(ps_3_month_16S, measures = "Shannon")

# Convert phyloseq object to dataframe and add Shannon diversity data
df <- as(sample_data(ps_3_month_16S), "data.frame")
df$Shannon <- shannon_data_ps_3_month_16S$Shannon

# Set the order of the Treatment factor to D, C, R
df$Treatment <- factor(df$Treatment, levels = c("C", "D", "R"))

# Filter the dataframe for only STEM data
df_stem <- df %>% filter(Organ == "STEM")

# Perform pairwise Wilcoxon test with BenjaminiHochberg adjustment on Shannon diversity for STEM
pairwise_results_stem <- df_stem %>%
  do(tidy(pairwise.wilcox.test(.$Shannon, .$Treatment, p.adjust.method = "BH")))

# Extract p-values and comparisons for STEM (calculated, but not displayed)
comparisons <- list(c("C", "D"), c("C", "R"), c("D", "R"))
stem_annotations <- pairwise_results_stem %>%
  mutate(p_value_text = paste0("p = ", format(p.value, digits = 2))) %>%
  pull(p_value_text)

# Create the Shannon diversity plot for STEM only (without significance annotations on the plot)
shannon_plot_ps_3_month_16S_stem <- ggplot(df_stem, aes(x = Treatment, y = Shannon, fill = Treatment)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  labs(x = NULL, y = "Shannon Diversity Index") +
  scale_fill_manual(values = c("C" = "#1F77B4", "D" = "#2CA02C", "R" = "#FF7F0E"), 
                    breaks = c("C", "D", "R"),
                    labels = c("Control", "Rain Exclusion", "Ringbarked"),
                    name = "Treatment") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  ylim(0.8, 5.1)

# Print the plot for STEM
print(shannon_plot_ps_3_month_16S_stem)


# Repeating with only leaves ----------------
# Estimate Shannon diversity for Control (C), Rain Exclusion (D), and Ringbarked (R)
shannon_data_ps_3_month_16S <- estimate_richness(ps_3_month_16S, measures = "Shannon")

# Convert phyloseq object to dataframe and add Shannon diversity data
df <- as(sample_data(ps_3_month_16S), "data.frame")
df$Shannon <- shannon_data_ps_3_month_16S$Shannon

# Set the order of the Treatment factor to D, C, R
df$Treatment <- factor(df$Treatment, levels = c("C", "D", "R"))

# Filter the dataframe for only LEAF data
df_leaf <- df %>% filter(Organ == "LEAF")

# Perform pairwise Wilcoxon test with BenjaminiHochberg adjustment on Shannon diversity for LEAF
pairwise_results_leaf <- df_leaf %>%
  do(tidy(pairwise.wilcox.test(.$Shannon, .$Treatment, p.adjust.method = "BH")))

# Extract p-values and comparisons for LEAF (calculated, but not displayed)
comparisons <- list(c("C", "D"), c("C", "R"), c("D", "R"))
leaf_annotations <- pairwise_results_leaf %>%
  mutate(p_value_text = paste0("p = ", format(p.value, digits = 2))) %>%
  pull(p_value_text)

# Create the Shannon diversity plot for LEAF only (without significance annotations on the plot)
shannon_plot_ps_3_month_16S_leaf <- ggplot(df_leaf, aes(x = Treatment, y = Shannon, fill = Treatment)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  labs(x = NULL, y = "Shannon Diversity Index") +
  scale_fill_manual(values = c("C" = "#1F77B4", "D" = "#2CA02C", "R" = "#FF7F0E"), 
                    breaks = c("C", "D", "R"),
                    labels = c("Control", "Rain Exclusion", "Ringbarked"),
                    name = "Treatment") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  ylim(0.8, 5.1)

# Print the plot for LEAF
print(shannon_plot_ps_3_month_16S_leaf)

#now repeating for Root --------------------
# Estimate Shannon diversity for Control (C), Rain Exclusion (D), and Ringbarked (R)
shannon_data_ps_3_month_16S <- estimate_richness(ps_3_month_16S, measures = "Shannon")

# Convert phyloseq object to dataframe and add Shannon diversity data
df <- as(sample_data(ps_3_month_16S), "data.frame")
df$Shannon <- shannon_data_ps_3_month_16S$Shannon

# Set the order of the Treatment factor to D, C, R
df$Treatment <- factor(df$Treatment, levels = c("C", "D", "R"))

# Filter the dataframe for only ROOT data
df_root <- df %>% filter(Organ == "ROOT")

# Perform pairwise Wilcoxon test with BenjaminiHochberg adjustment on Shannon diversity for ROOT
pairwise_results_root <- df_root %>%
  do(tidy(pairwise.wilcox.test(.$Shannon, .$Treatment, p.adjust.method = "BH")))

# Extract p-values and comparisons for ROOT (calculated, but not displayed)
comparisons <- list(c("C", "D"), c("C", "R"), c("D", "R"))
root_annotations <- pairwise_results_root %>%
  mutate(p_value_text = paste0("p = ", format(p.value, digits = 2))) %>%
  pull(p_value_text)

# Create the Shannon diversity plot for ROOT only (without significance annotations on the plot)
shannon_plot_ps_3_month_16S_root <- ggplot(df_root, aes(x = Treatment, y = Shannon, fill = Treatment)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  labs(x = NULL, y = "Shannon Diversity Index") +
  scale_fill_manual(values = c("C" = "#1F77B4", "D" = "#2CA02C", "R" = "#FF7F0E"), 
                    breaks = c("C", "D", "R"),
                    labels = c("Control", "Rain Exclusion", "Ringbarked"),
                    name = "Treatment") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  ylim(0.8, 5.1)

# Print the plot for ROOT
print(shannon_plot_ps_3_month_16S_root)

#Repeating with ITS ---------------------
# Estimate Shannon diversity for Control (C), Rain Exclusion (D), and Ringbarked (R)
shannon_data_ps_3_month_ITS <- estimate_richness(ps_3_month_ITS, measures = "Shannon")

# Convert phyloseq object to dataframe and add Shannon diversity data
df <- as(sample_data(ps_3_month_ITS), "data.frame")
df$Shannon <- shannon_data_ps_3_month_ITS$Shannon

# Set the order of the Treatment factor to D, C, R
df$Treatment <- factor(df$Treatment, levels = c("C", "D", "R"))

# Filter the dataframe for only STEM data
df_stem <- df %>% filter(Organ == "STEM")

# Perform pairwise Wilcoxon test with BenjaminiHochberg adjustment on Shannon diversity for STEM
pairwise_results_stem <- df_stem %>%
  do(tidy(pairwise.wilcox.test(.$Shannon, .$Treatment, p.adjust.method = "BH")))

# Extract p-values and comparisons for STEM (calculated, but not displayed)
comparisons <- list(c("C", "D"), c("C", "R"), c("D", "R"))
stem_annotations <- pairwise_results_stem %>%
  mutate(p_value_text = paste0("p = ", format(p.value, digits = 2))) %>%
  pull(p_value_text)

# Create the Shannon diversity plot for STEM only (without significance annotations on the plot)
shannon_plot_ps_3_month_ITS_stem <- ggplot(df_stem, aes(x = Treatment, y = Shannon, fill = Treatment)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  labs(x = NULL, y = "Shannon Diversity Index") +
  scale_fill_manual(values = c("C" = "#1F77B4", "D" = "#2CA02C", "R" = "#FF7F0E"), 
                    breaks = c("C", "D", "R"),
                    labels = c("Control", "Rain Exclusion", "Ringbarked"),
                    name = "Treatment") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  ylim(0.8, 5.1)

# Print the plot for STEM
print(shannon_plot_ps_3_month_ITS_stem)

# Repeating with only leaves ----------------
# Estimate Shannon diversity for Control (C), Rain Exclusion (D), and Ringbarked (R)
shannon_data_ps_3_month_ITS <- estimate_richness(ps_3_month_ITS, measures = "Shannon")

# Convert phyloseq object to dataframe and add Shannon diversity data
df <- as(sample_data(ps_3_month_ITS), "data.frame")
df$Shannon <- shannon_data_ps_3_month_ITS$Shannon

# Set the order of the Treatment factor to D, C, R
df$Treatment <- factor(df$Treatment, levels = c("C", "D", "R"))

# Filter the dataframe for only LEAF data
df_leaf <- df %>% filter(Organ == "LEAF")

# Perform pairwise Wilcoxon test with BenjaminiHochberg adjustment on Shannon diversity for LEAF
pairwise_results_leaf <- df_leaf %>%
  do(tidy(pairwise.wilcox.test(.$Shannon, .$Treatment, p.adjust.method = "BH")))

# Extract p-values and comparisons for LEAF (calculated, but not displayed)
comparisons <- list(c("C", "D"), c("C", "R"), c("D", "R"))
leaf_annotations <- pairwise_results_leaf %>%
  mutate(p_value_text = paste0("p = ", format(p.value, digits = 2))) %>%
  pull(p_value_text)

# Create the Shannon diversity plot for LEAF only (without significance annotations on the plot)
shannon_plot_ps_3_month_ITS_leaf <- ggplot(df_leaf, aes(x = Treatment, y = Shannon, fill = Treatment)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  labs(x = NULL, y = "Shannon Diversity Index") +
  scale_fill_manual(values = c("C" = "#1F77B4", "D" = "#2CA02C", "R" = "#FF7F0E"), 
                    breaks = c("C", "D", "R"),
                    labels = c("Control", "Rain Exclusion", "Ringbarked"),
                    name = "Treatment") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  ylim(0.8, 5.1)

# Print the plot for LEAF
print(shannon_plot_ps_3_month_ITS_leaf)


#now repeating for Root --------------------
# Estimate Shannon diversity for Control (C), Rain Exclusion (D), and Ringbarked (R)
shannon_data_ps_3_month_ITS <- estimate_richness(ps_3_month_ITS, measures = "Shannon")

# Convert phyloseq object to dataframe and add Shannon diversity data
df <- as(sample_data(ps_3_month_ITS), "data.frame")
df$Shannon <- shannon_data_ps_3_month_ITS$Shannon

# Set the order of the Treatment factor to D, C, R
df$Treatment <- factor(df$Treatment, levels = c("C", "D", "R"))

# Filter the dataframe for only ROOT data
df_root <- df %>% filter(Organ == "ROOT")

# Perform pairwise Wilcoxon test with BenjaminiHochberg adjustment on Shannon diversity for ROOT
pairwise_results_root <- df_root %>%
  do(tidy(pairwise.wilcox.test(.$Shannon, .$Treatment, p.adjust.method = "BH")))

# Extract p-values and comparisons for ROOT (calculated, but not displayed)
comparisons <- list(c("C", "D"), c("C", "R"), c("D", "R"))
root_annotations <- pairwise_results_root %>%
  mutate(p_value_text = paste0("p = ", format(p.value, digits = 2))) %>%
  pull(p_value_text)

# Create the Shannon diversity plot for ROOT only (without significance annotations on the plot)
shannon_plot_ps_3_month_ITS_root <- ggplot(df_root, aes(x = Treatment, y = Shannon, fill = Treatment)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  labs(x = NULL, y = "Shannon Diversity Index") +
  scale_fill_manual(values = c("C" = "#1F77B4", "D" = "#2CA02C", "R" = "#FF7F0E"), 
                    breaks = c("C", "D", "R"),
                    labels = c("Control", "Rain Exclusion", "Ringbarked"),
                    name = "Treatment") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  ylim(0.8, 5.1)

# Print the plot for ROOT
print(shannon_plot_ps_3_month_ITS_root)
```

#Alpha diversity - Time Point 3 - 16S
```{r}
# Filter the phyloseq object for STEM data
ps_6_month_16S_STEM <- subset_samples(ps_6_month_16S, Organ == "STEM")

# Estimate Shannon diversity for the STEM subset
diversity_data_STEM <- estimate_richness(ps_6_month_16S_STEM, measures = c("Shannon"))

# Convert phyloseq sample_data for STEM to dataframe
POST_16S_opt_1_df_16S_STEM <- as(sample_data(ps_6_month_16S_STEM), "data.frame")

# Add Shannon diversity to the STEM dataframe
POST_16S_opt_1_df_16S_STEM$Shannon <- diversity_data_STEM$Shannon

# Reshape data for Shannon diversity index only
POST_16S_opt_1_df_long_STEM <- POST_16S_opt_1_df_16S_STEM %>%
  pivot_longer(cols = "Shannon", 
               names_to = "Diversity_Index", 
               values_to = "Value")

# Plot for Shannon diversity index in STEM
POST_16S_opt_1_alpha_STEM <- ggplot(POST_16S_opt_1_df_long_STEM, aes(x = Treatment, y = Value, fill = Treatment)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  facet_wrap(~ AOD, scales = "free_y", 
             labeller = labeller(AOD = c("N" = "No AOD", "Y" = "With AOD"))) +  # Modify facet as needed
  labs(x = NULL, y = "Shannon Diversity Index") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  scale_fill_manual(
    values = c("C" = "#1F77B4", "D" = "#2CA02C", "R" = "#FF7F0E"), # Colorblind-friendly colors
    labels = c("C" = "Control", "D" = "Rain Exclusion", "R" = "Ringbarked")
  )

# Print the updated plot
print(POST_16S_opt_1_alpha_STEM)

# Perform Kruskal-Wallis test for STEM only
POST_16S_opt_1_kruskal_results_STEM <- POST_16S_opt_1_df_long_STEM %>%
  group_by(AOD) %>%
  summarise(
    test_result = list(kruskal.test(Value ~ Treatment, data = cur_data())),
    .groups = "drop"
  )

# Print Kruskal-Wallis results for STEM
POST_16S_opt_1_kruskal_results_STEM %>%
  rowwise() %>%
  mutate(p_value = test_result$p.value) %>%
  select(AOD, p_value)


# Perform Pairwise Wilcoxon test for Shannon Diversity for STEM
POST_16S_opt_1_wilcoxon_results_STEM <- POST_16S_opt_1_df_long_STEM %>%
  group_by(AOD) %>%
  pairwise_wilcox_test(Value ~ Treatment, p.adjust.method = "bonferroni")

# Print the Wilcoxon test results for STEM
print(POST_16S_opt_1_wilcoxon_results_STEM)

# Add statistical significance annotations to your STEM plot
POST_16S_opt_1_annotated_results_STEM <- POST_16S_opt_1_wilcoxon_results_STEM %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Calculate max_value and y.position for annotations
POST_16S_opt_1_max_y_STEM <- POST_16S_opt_1_df_long_STEM %>%
  group_by(AOD, Treatment) %>%
  summarize(max_value = max(Value, na.rm = TRUE)) %>%
  ungroup()

POST_16S_opt_1_annotated_results_STEM$max_value <- POST_16S_opt_1_max_y_STEM$max_value
POST_16S_opt_1_annotated_results_STEM$Treatment <- POST_16S_opt_1_max_y_STEM$Treatment

POST_16S_opt_1_annotated_results_STEM <- POST_16S_opt_1_annotated_results_STEM %>%
  mutate(y.position = max_value + 0.1)

# Add p-value annotations to the plot
POST_16S_opt_1_alpha_STEM <- POST_16S_opt_1_alpha_STEM +
  stat_pvalue_manual(POST_16S_opt_1_annotated_results_STEM,
                     label = "Significance",
                     y.position = "y.position",
                     tip.length = 0.01,
                     size = 10,
                     bracket.size = 2.5,
                     hide.ns = TRUE)

# Print the annotated plot for STEM
print(POST_16S_opt_1_alpha_STEM)


#Repeating with AOD ---------

# Filter the phyloseq object for STEM data
ps_6_month_16S_STEM_AOD <- subset_samples(ps_6_month_16S, Organ == "STEM")

# Estimate Shannon diversity for the STEM subset
diversity_data_STEM_AOD <- estimate_richness(ps_6_month_16S_STEM_AOD, measures = c("Shannon"))

# Convert phyloseq sample_data for STEM to dataframe
POST_16S_opt_1_df_16S_STEM_AOD <- as(sample_data(ps_6_month_16S_STEM_AOD), "data.frame")

# Add Shannon diversity to the STEM dataframe
POST_16S_opt_1_df_16S_STEM_AOD$Shannon <- diversity_data_STEM_AOD$Shannon

# Reshape data for Shannon diversity index only
POST_16S_opt_1_df_long_STEM_AOD <- POST_16S_opt_1_df_16S_STEM_AOD %>%
  pivot_longer(cols = "Shannon", 
               names_to = "Diversity_Index", 
               values_to = "Value")

# Create plot with AOD on x-axis and faceting by Treatment (for STEM only)
POST_16S_opt_1_alpha_STEM_AOD <- ggplot(POST_16S_opt_1_df_long_STEM_AOD, aes(x = AOD, y = Value, fill = AOD)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  facet_wrap(~ Treatment, scales = "free_y", 
             labeller = labeller(Treatment = c(
               "C" = "Control",
               "D" = "Rain Exclusion",
               "R" = "Ringbarked"
             ))) +  # Map labels for Treatment
  labs(x = NULL, y = "Shannon Diversity Index") +  # Label change
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  scale_fill_manual(
    values = c("N" = "#4C4CFF", "Y" = "#FF4C4C"), # Colorblind-friendly colors
    labels = c("N" = "No AOD", "Y" = "With AOD")
  )

# Print the plot
print(POST_16S_opt_1_alpha_STEM_AOD)

# Perform Kruskal-Wallis test grouped by Treatment and AOD for STEM
POST_16S_opt_1_kruskal_results_STEM_AOD <- POST_16S_opt_1_df_long_STEM_AOD %>%
  group_by(Treatment) %>%
  summarise(
    test_result = list(kruskal.test(Value ~ AOD, data = cur_data())),
    .groups = "drop"
  )

# Extract and print Kruskal-Wallis p-values for STEM
POST_16S_opt_1_kruskal_results_STEM_AOD <- POST_16S_opt_1_kruskal_results_STEM_AOD %>%
  rowwise() %>%
  mutate(p_value = test_result$p.value) %>%
  select(Treatment, p_value)
print(POST_16S_opt_1_kruskal_results_STEM_AOD)

# Perform pairwise Wilcoxon rank-sum test grouped by Treatment and AOD for STEM
POST_16S_opt_1_wilcoxon_results_STEM_AOD <- POST_16S_opt_1_df_long_STEM_AOD %>%
  group_by(Treatment) %>%
  pairwise_wilcox_test(Value ~ AOD, p.adjust.method = "bonferroni")

# Add significance annotations
POST_16S_opt_1_annotated_results_STEM_AOD <- POST_16S_opt_1_wilcoxon_results_STEM_AOD %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Calculate maximum y-values for placement of annotations for STEM
POST_16S_opt_1_max_y_STEM_AOD <- POST_16S_opt_1_df_long_STEM_AOD %>%
  group_by(Treatment, AOD) %>%
  summarize(max_value = max(Value, na.rm = TRUE)) %>%
  ungroup()

# Ensure that AOD is included in the Wilcoxon test results
POST_16S_opt_1_wilcoxon_results_STEM_with_AOD <- POST_16S_opt_1_wilcoxon_results_STEM_AOD %>%
  left_join(POST_16S_opt_1_df_long_STEM_AOD %>% select(Treatment, AOD) %>% distinct(), by = "Treatment")

# Add significance annotations based on adjusted p-values
POST_16S_opt_1_wilcoxon_results_STEM_with_AOD <- POST_16S_opt_1_wilcoxon_results_STEM_with_AOD %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Now merge the max_value from POST_16S_opt_1_max_y_STEM into the Wilcoxon test results
POST_16S_opt_1_annotated_results_STEM_AOD <- POST_16S_opt_1_wilcoxon_results_STEM_with_AOD %>%
  left_join(POST_16S_opt_1_max_y_STEM_AOD, by = c("Treatment", "AOD"))

# Add y.position for annotation (e.g., adding 0.1 to max_value for visual placement)
POST_16S_opt_1_annotated_results_STEM_AOD <- POST_16S_opt_1_annotated_results_STEM_AOD %>%
  mutate(y.position = max_value + 0.1)

# Now you can safely add the significance annotations to the plot
POST_16S_opt_1_alpha_STEM_AOD <- POST_16S_opt_1_alpha_STEM_AOD +
  stat_pvalue_manual(POST_16S_opt_1_annotated_results_STEM_AOD,
                     label = "Significance",
                     y.position = "y.position",
                     tip.length = 0.01,
                     size = 10,
                     bracket.size = 2.5,
                     hide.ns = TRUE)

# Print the final plot with annotations for STEM
print(POST_16S_opt_1_alpha_STEM_AOD)

#-------------- Repeat with ROOT  -----------------

# Filter the phyloseq object for ROOT data
ps_6_month_16S_ROOT <- subset_samples(ps_6_month_16S, Organ == "ROOT")

# Estimate Shannon diversity for the ROOT subset
diversity_data_ROOT <- estimate_richness(ps_6_month_16S_ROOT, measures = c("Shannon"))

# Convert phyloseq sample_data for ROOT to dataframe
POST_16S_opt_1_df_16S_ROOT <- as(sample_data(ps_6_month_16S_ROOT), "data.frame")

# Add Shannon diversity to the ROOT dataframe
POST_16S_opt_1_df_16S_ROOT$Shannon <- diversity_data_ROOT$Shannon

# Reshape data for Shannon diversity index only
POST_16S_opt_1_df_long_ROOT <- POST_16S_opt_1_df_16S_ROOT %>%
  pivot_longer(cols = "Shannon", 
               names_to = "Diversity_Index", 
               values_to = "Value")

# Plot for Shannon diversity index in ROOT
POST_16S_opt_1_alpha_ROOT <- ggplot(POST_16S_opt_1_df_long_ROOT, aes(x = Treatment, y = Value, fill = Treatment)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  facet_wrap(~ AOD, scales = "free_y", 
             labeller = labeller(AOD = c("N" = "No AOD", "Y" = "With AOD"))) +  # Modify facet as needed
  labs(x = NULL, y = "Shannon Diversity Index") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  scale_fill_manual(
    values = c("C" = "#1F77B4", "D" = "#2CA02C", "R" = "#FF7F0E"), # Colorblind-friendly colors
    labels = c("C" = "Control", "D" = "Rain Exclusion", "R" = "Ringbarked")
  )

# Print the updated plot
print(POST_16S_opt_1_alpha_ROOT)

# Perform Kruskal-Wallis test for ROOT only
POST_16S_opt_1_kruskal_results_ROOT <- POST_16S_opt_1_df_long_ROOT %>%
  group_by(AOD) %>%
  summarise(
    test_result = list(kruskal.test(Value ~ Treatment, data = cur_data())),
    .groups = "drop"
  )

# Print Kruskal-Wallis results for ROOT
POST_16S_opt_1_kruskal_results_ROOT %>%
  rowwise() %>%
  mutate(p_value = test_result$p.value) %>%
  select(AOD, p_value)

# Perform Pairwise Wilcoxon test for Shannon Diversity for ROOT
POST_16S_opt_1_wilcoxon_results_ROOT <- POST_16S_opt_1_df_long_ROOT %>%
  group_by(AOD) %>%
  pairwise_wilcox_test(Value ~ Treatment, p.adjust.method = "bonferroni")

# Print the Wilcoxon test results for ROOT
print(POST_16S_opt_1_wilcoxon_results_ROOT)

# Add statistical significance annotations to your ROOT plot
POST_16S_opt_1_annotated_results_ROOT <- POST_16S_opt_1_wilcoxon_results_ROOT %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Calculate max_value and y.position for annotations
POST_16S_opt_1_max_y_ROOT <- POST_16S_opt_1_df_long_ROOT %>%
  group_by(AOD, Treatment) %>%
  summarize(max_value = max(Value, na.rm = TRUE)) %>%
  ungroup()

POST_16S_opt_1_annotated_results_ROOT$max_value <- POST_16S_opt_1_max_y_ROOT$max_value
POST_16S_opt_1_annotated_results_ROOT$Treatment <- POST_16S_opt_1_max_y_ROOT$Treatment

POST_16S_opt_1_annotated_results_ROOT <- POST_16S_opt_1_annotated_results_ROOT %>%
  mutate(y.position = max_value + 0.1)

# Add p-value annotations to the plot
POST_16S_opt_1_alpha_ROOT <- POST_16S_opt_1_alpha_ROOT +
  stat_pvalue_manual(POST_16S_opt_1_annotated_results_ROOT,
                     label = "Significance",
                     y.position = "y.position",
                     tip.length = 0.01,
                     size = 10,
                     bracket.size = 2.5,
                     hide.ns = TRUE)

# Print the annotated plot for ROOT
print(POST_16S_opt_1_alpha_ROOT)


#Repeating with AOD ---------

# Filter the phyloseq object for ROOT data
ps_6_month_16S_ROOT_AOD <- subset_samples(ps_6_month_16S, Organ == "ROOT")

# Estimate Shannon diversity for the ROOT subset
diversity_data_ROOT_AOD <- estimate_richness(ps_6_month_16S_ROOT_AOD, measures = c("Shannon"))

# Convert phyloseq sample_data for ROOT to dataframe
POST_16S_opt_1_df_16S_ROOT_AOD <- as(sample_data(ps_6_month_16S_ROOT_AOD), "data.frame")

# Add Shannon diversity to the ROOT dataframe
POST_16S_opt_1_df_16S_ROOT_AOD$Shannon <- diversity_data_ROOT_AOD$Shannon

# Reshape data for Shannon diversity index only
POST_16S_opt_1_df_long_ROOT_AOD <- POST_16S_opt_1_df_16S_ROOT_AOD %>%
  pivot_longer(cols = "Shannon", 
               names_to = "Diversity_Index", 
               values_to = "Value")

# Create plot with AOD on x-axis and faceting by Treatment (for ROOT only)
POST_16S_opt_1_alpha_ROOT_AOD <- ggplot(POST_16S_opt_1_df_long_ROOT_AOD, aes(x = AOD, y = Value, fill = AOD)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  facet_wrap(~ Treatment, scales = "free_y", 
             labeller = labeller(Treatment = c(
               "C" = "Control",
               "D" = "Rain Exclusion",
               "R" = "Ringbarked"
             ))) +  # Map labels for Treatment
  labs(x = NULL, y = "Shannon Diversity Index") +  # Label change
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  scale_fill_manual(
    values = c("N" = "#4C4CFF", "Y" = "#FF4C4C"), # Colorblind-friendly colors
    labels = c("N" = "No AOD", "Y" = "With AOD")
  )

# Print the plot
print(POST_16S_opt_1_alpha_ROOT_AOD)

# Perform Kruskal-Wallis test grouped by Treatment and AOD for ROOT
POST_16S_opt_1_kruskal_results_ROOT_AOD <- POST_16S_opt_1_df_long_ROOT_AOD %>%
  group_by(Treatment) %>%
  summarise(
    test_result = list(kruskal.test(Value ~ AOD, data = cur_data())),
    .groups = "drop"
  )

# Extract and print Kruskal-Wallis p-values for ROOT
POST_16S_opt_1_kruskal_results_ROOT_AOD <- POST_16S_opt_1_kruskal_results_ROOT_AOD %>%
  rowwise() %>%
  mutate(p_value = test_result$p.value) %>%
  select(Treatment, p_value)
print(POST_16S_opt_1_kruskal_results_ROOT_AOD)

# Perform pairwise Wilcoxon rank-sum test grouped by Treatment and AOD for ROOT
POST_16S_opt_1_wilcoxon_results_ROOT_AOD <- POST_16S_opt_1_df_long_ROOT_AOD %>%
  group_by(Treatment) %>%
  pairwise_wilcox_test(Value ~ AOD, p.adjust.method = "bonferroni")

# Add significance annotations
POST_16S_opt_1_annotated_results_ROOT_AOD <- POST_16S_opt_1_wilcoxon_results_ROOT_AOD %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Calculate maximum y-values for placement of annotations for ROOT
POST_16S_opt_1_max_y_ROOT_AOD <- POST_16S_opt_1_df_long_ROOT_AOD %>%
  group_by(Treatment, AOD) %>%
  summarize(max_value = max(Value, na.rm = TRUE)) %>%
  ungroup()

# Ensure that AOD is included in the Wilcoxon test results
POST_16S_opt_1_wilcoxon_results_ROOT_with_AOD <- POST_16S_opt_1_wilcoxon_results_ROOT_AOD %>%
  left_join(POST_16S_opt_1_df_long_ROOT_AOD %>% select(Treatment, AOD) %>% distinct(), by = "Treatment")

# Add significance annotations based on adjusted p-values
POST_16S_opt_1_wilcoxon_results_ROOT_with_AOD <- POST_16S_opt_1_wilcoxon_results_ROOT_with_AOD %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Now merge the max_value from POST_16S_opt_1_max_y_ROOT into the Wilcoxon test results
POST_16S_opt_1_annotated_results_ROOT_AOD <- POST_16S_opt_1_wilcoxon_results_ROOT_with_AOD %>%
  left_join(POST_16S_opt_1_max_y_ROOT_AOD, by = c("Treatment", "AOD"))

# Add y.position for annotation (e.g., adding 0.1 to max_value for visual placement)
POST_16S_opt_1_annotated_results_ROOT_AOD <- POST_16S_opt_1_annotated_results_ROOT_AOD %>%
  mutate(y.position = max_value + 0.1) %>%
  filter(row_number() %% 2 == 1)  # Keep only odd-numbered rows



# Now you can safely add the significance annotations to the plot
POST_16S_opt_1_alpha_ROOT_AOD <- POST_16S_opt_1_alpha_ROOT_AOD +
  stat_pvalue_manual(POST_16S_opt_1_annotated_results_ROOT_AOD,
                     label = "Significance",
                     y.position = "y.position",
                     tip.length = 0.01,
                     size = 10,
                     bracket.size = 2.5,
                     hide.ns = TRUE)

# Print the final plot with annotations for ROOT
print(POST_16S_opt_1_alpha_ROOT_AOD)
```

#Alpha diversity - Time point 4 - 16S
```{r}
# Filter the phyloseq object for STEM data
ps_18_month_16S_STEM <- subset_samples(ps_18_month_16S, Organ == "STEM")

# Estimate Shannon diversity for the STEM subset
diversity_data_STEM <- estimate_richness(ps_18_month_16S_STEM, measures = c("Shannon"))

# Convert phyloseq sample_data for STEM to dataframe
LPOST_16S_opt_1_df_16S_STEM <- as(sample_data(ps_18_month_16S_STEM), "data.frame")

# Add Shannon diversity to the STEM dataframe
LPOST_16S_opt_1_df_16S_STEM$Shannon <- diversity_data_STEM$Shannon

# Reshape data for Shannon diversity index only
LPOST_16S_opt_1_df_long_STEM <- LPOST_16S_opt_1_df_16S_STEM %>%
  pivot_longer(cols = "Shannon", 
               names_to = "Diversity_Index", 
               values_to = "Value")

# Plot for Shannon diversity index in STEM
LPOST_16S_opt_1_alpha_STEM <- ggplot(LPOST_16S_opt_1_df_long_STEM, aes(x = Treatment, y = Value, fill = Treatment)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  facet_wrap(~ AOD, scales = "free_y", 
             labeller = labeller(AOD = c("N" = "No AOD", "Y" = "With AOD"))) +  # Modify facet as needed
  labs(x = NULL, y = "Shannon Diversity Index") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  scale_fill_manual(
    values = c("C" = "#1F77B4", "D" = "#2CA02C", "R" = "#FF7F0E"), # Colorblind-friendly colors
    labels = c("C" = "Control", "D" = "Rain Exclusion", "R" = "Ringbarked")
  )

# Print the updated plot
print(LPOST_16S_opt_1_alpha_STEM)

# Perform Kruskal-Wallis test for STEM only
LPOST_16S_opt_1_kruskal_results_STEM <- LPOST_16S_opt_1_df_long_STEM %>%
  group_by(AOD) %>%
  summarise(
    test_result = list(kruskal.test(Value ~ Treatment, data = cur_data())),
    .groups = "drop"
  )

# Print Kruskal-Wallis results for STEM
LPOST_16S_opt_1_kruskal_results_STEM %>%
  rowwise() %>%
  mutate(p_value = test_result$p.value) %>%
  select(AOD, p_value)

# Perform Pairwise Wilcoxon test for Shannon Diversity for STEM
LPOST_16S_opt_1_wilcoxon_results_STEM <- LPOST_16S_opt_1_df_long_STEM %>%
  group_by(AOD) %>%
  pairwise_wilcox_test(Value ~ Treatment, p.adjust.method = "bonferroni")

# Print the Wilcoxon test results for STEM
print(LPOST_16S_opt_1_wilcoxon_results_STEM)

# Add statistical significance annotations to your STEM plot
LPOST_16S_opt_1_annotated_results_STEM <- LPOST_16S_opt_1_wilcoxon_results_STEM %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Calculate max_value and y.position for annotations
LPOST_16S_opt_1_max_y_STEM <- LPOST_16S_opt_1_df_long_STEM %>%
  group_by(AOD, Treatment) %>%
  summarize(max_value = max(Value, na.rm = TRUE)) %>%
  ungroup()

LPOST_16S_opt_1_annotated_results_STEM$max_value <- LPOST_16S_opt_1_max_y_STEM$max_value
LPOST_16S_opt_1_annotated_results_STEM$Treatment <- LPOST_16S_opt_1_max_y_STEM$Treatment

LPOST_16S_opt_1_annotated_results_STEM <- LPOST_16S_opt_1_annotated_results_STEM %>%
  mutate(y.position = max_value + 0.1)

# Add p-value annotations to the plot
LPOST_16S_opt_1_alpha_STEM <- LPOST_16S_opt_1_alpha_STEM +
  stat_pvalue_manual(LPOST_16S_opt_1_annotated_results_STEM,
                     label = "Significance",
                     y.position = "y.position",
                     tip.length = 0.01,
                     size = 10,
                     bracket.size = 2.5,
                     hide.ns = TRUE)

# Print the annotated plot for STEM
print(LPOST_16S_opt_1_alpha_STEM)


#Repeating with AOD ---------

# Filter the phyloseq object for STEM data
ps_18_month_16S_STEM_AOD <- subset_samples(ps_18_month_16S, Organ == "STEM")

# Estimate Shannon diversity for the STEM subset
diversity_data_STEM_AOD <- estimate_richness(ps_18_month_16S_STEM_AOD, measures = c("Shannon"))

# Convert phyloseq sample_data for STEM to dataframe
LPOST_16S_opt_1_df_16S_STEM_AOD <- as(sample_data(ps_18_month_16S_STEM_AOD), "data.frame")

# Add Shannon diversity to the STEM dataframe
LPOST_16S_opt_1_df_16S_STEM_AOD$Shannon <- diversity_data_STEM_AOD$Shannon

# Reshape data for Shannon diversity index only
LPOST_16S_opt_1_df_long_STEM_AOD <- LPOST_16S_opt_1_df_16S_STEM_AOD %>%
  pivot_longer(cols = "Shannon", 
               names_to = "Diversity_Index", 
               values_to = "Value")

# Create plot with AOD on x-axis and faceting by Treatment (for STEM only)
LPOST_16S_opt_1_alpha_STEM_AOD <- ggplot(LPOST_16S_opt_1_df_long_STEM_AOD, aes(x = AOD, y = Value, fill = AOD)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  facet_wrap(~ Treatment, scales = "free_y", 
             labeller = labeller(Treatment = c(
               "C" = "Control",
               "D" = "Rain Exclusion",
               "R" = "Ringbarked"
             ))) +  # Map labels for Treatment
  labs(x = NULL, y = "Shannon Diversity Index") +  # Label change
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  scale_fill_manual(
    values = c("N" = "#4C4CFF", "Y" = "#FF4C4C"), # Colorblind-friendly colors
    labels = c("N" = "No AOD", "Y" = "With AOD")
  )

# Print the plot
print(LPOST_16S_opt_1_alpha_STEM_AOD)

# Perform Kruskal-Wallis test grouped by Treatment and AOD for STEM
LPOST_16S_opt_1_kruskal_results_STEM_AOD <- LPOST_16S_opt_1_df_long_STEM_AOD %>%
  group_by(Treatment) %>%
  summarise(
    test_result = list(kruskal.test(Value ~ AOD, data = cur_data())),
    .groups = "drop"
  )

# Extract and print Kruskal-Wallis p-values for STEM
LPOST_16S_opt_1_kruskal_results_STEM_AOD <- LPOST_16S_opt_1_kruskal_results_STEM_AOD %>%
  rowwise() %>%
  mutate(p_value = test_result$p.value) %>%
  select(Treatment, p_value)
print(LPOST_16S_opt_1_kruskal_results_STEM_AOD)

# Perform pairwise Wilcoxon rank-sum test grouped by Treatment and AOD for STEM
LPOST_16S_opt_1_wilcoxon_results_STEM_AOD <- LPOST_16S_opt_1_df_long_STEM_AOD %>%
  group_by(Treatment) %>%
  pairwise_wilcox_test(Value ~ AOD, p.adjust.method = "bonferroni")

# Add significance annotations
LPOST_16S_opt_1_annotated_results_STEM_AOD <- LPOST_16S_opt_1_wilcoxon_results_STEM_AOD %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Calculate maximum y-values for placement of annotations for STEM
LPOST_16S_opt_1_max_y_STEM_AOD <- LPOST_16S_opt_1_df_long_STEM_AOD %>%
  group_by(Treatment, AOD) %>%
  summarize(max_value = max(Value, na.rm = TRUE)) %>%
  ungroup()

# Ensure that AOD is included in the Wilcoxon test results
LPOST_16S_opt_1_wilcoxon_results_STEM_with_AOD <- LPOST_16S_opt_1_wilcoxon_results_STEM_AOD %>%
  left_join(LPOST_16S_opt_1_df_long_STEM_AOD %>% select(Treatment, AOD) %>% distinct(), by = "Treatment")

# Add significance annotations based on adjusted p-values
LPOST_16S_opt_1_wilcoxon_results_STEM_with_AOD <- LPOST_16S_opt_1_wilcoxon_results_STEM_with_AOD %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Now merge the max_value from LPOST_16S_opt_1_max_y_STEM into the Wilcoxon test results
LPOST_16S_opt_1_annotated_results_STEM_AOD <- LPOST_16S_opt_1_wilcoxon_results_STEM_with_AOD %>%
  left_join(LPOST_16S_opt_1_max_y_STEM_AOD, by = c("Treatment", "AOD"))

# Add y.position for annotation (e.g., adding 0.1 to max_value for visual placement)
LPOST_16S_opt_1_annotated_results_STEM_AOD <- LPOST_16S_opt_1_annotated_results_STEM_AOD %>%
  mutate(y.position = max_value + 0.1) %>%
  filter(row_number() %% 2 == 1)  # Keeps only every other row


# Now you can safely add the significance annotations to the plot
LPOST_16S_opt_1_alpha_STEM_AOD <- LPOST_16S_opt_1_alpha_STEM_AOD +
  stat_pvalue_manual(LPOST_16S_opt_1_annotated_results_STEM_AOD,
                     label = "Significance",
                     y.position = "y.position",
                     tip.length = 0.01,
                     size = 10,
                     bracket.size = 2.5,
                     hide.ns = TRUE)

# Print the final plot with annotations for STEM
print(LPOST_16S_opt_1_alpha_STEM_AOD)




#Repeat with leaves ---------------

# Filter the phyloseq object for LEAF data
ps_18_month_16S_Leaf <- subset_samples(ps_18_month_16S, Organ == "LEAF")

# Estimate Shannon diversity for the LEAF subset
diversity_data_Leaf <- estimate_richness(ps_18_month_16S_Leaf, measures = c("Shannon"))

# Convert phyloseq sample_data for LEAF to dataframe
LPOST_16S_opt_1_df_16S_Leaf <- as(sample_data(ps_18_month_16S_Leaf), "data.frame")

# Add Shannon diversity to the LEAF dataframe
LPOST_16S_opt_1_df_16S_Leaf$Shannon <- diversity_data_Leaf$Shannon

# Reshape data for Shannon diversity index only
LPOST_16S_opt_1_df_long_Leaf <- LPOST_16S_opt_1_df_16S_Leaf %>%
  pivot_longer(cols = "Shannon", 
               names_to = "Diversity_Index", 
               values_to = "Value")

# Plot for Shannon diversity index in LEAF
LPOST_16S_opt_1_alpha_Leaf <- ggplot(LPOST_16S_opt_1_df_long_Leaf, aes(x = Treatment, y = Value, fill = Treatment)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  facet_wrap(~ AOD, scales = "free_y", 
             labeller = labeller(AOD = c("N" = "No AOD", "Y" = "With AOD"))) +  # Modify facet as needed
  labs(x = NULL, y = "Shannon Diversity Index") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  scale_fill_manual(
    values = c("C" = "#1F77B4", "D" = "#2CA02C", "R" = "#FF7F0E"), # Colorblind-friendly colors
    labels = c("C" = "Control", "D" = "Rain Exclusion", "R" = "Ringbarked")
  )

# Print the updated plot
print(LPOST_16S_opt_1_alpha_Leaf)

# Perform Kruskal-Wallis test for LEAF only
LPOST_16S_opt_1_kruskal_results_Leaf <- LPOST_16S_opt_1_df_long_Leaf %>%
  group_by(AOD) %>%
  summarise(
    test_result = list(kruskal.test(Value ~ Treatment, data = cur_data())),
    .groups = "drop"
  )

# Print Kruskal-Wallis results for LEAF
LPOST_16S_opt_1_kruskal_results_Leaf %>%
  rowwise() %>%
  mutate(p_value = test_result$p.value) %>%
  select(AOD, p_value)

# Perform Pairwise Wilcoxon test for Shannon Diversity for LEAF
LPOST_16S_opt_1_wilcoxon_results_Leaf <- LPOST_16S_opt_1_df_long_Leaf %>%
  group_by(AOD) %>%
  pairwise_wilcox_test(Value ~ Treatment, p.adjust.method = "bonferroni")

# Print the Wilcoxon test results for LEAF
print(LPOST_16S_opt_1_wilcoxon_results_Leaf)

# Add statistical significance annotations to your LEAF plot
LPOST_16S_opt_1_annotated_results_Leaf <- LPOST_16S_opt_1_wilcoxon_results_Leaf %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Calculate max_value and y.position for annotations
LPOST_16S_opt_1_max_y_Leaf <- LPOST_16S_opt_1_df_long_Leaf %>%
  group_by(AOD, Treatment) %>%
  summarize(max_value = max(Value, na.rm = TRUE)) %>%
  ungroup()

LPOST_16S_opt_1_annotated_results_Leaf$max_value <- LPOST_16S_opt_1_max_y_Leaf$max_value
LPOST_16S_opt_1_annotated_results_Leaf$Treatment <- LPOST_16S_opt_1_max_y_Leaf$Treatment

LPOST_16S_opt_1_annotated_results_Leaf <- LPOST_16S_opt_1_annotated_results_Leaf %>%
  mutate(y.position = max_value + 0.1)

# Add p-value annotations to the plot
LPOST_16S_opt_1_alpha_Leaf <- LPOST_16S_opt_1_alpha_Leaf +
  stat_pvalue_manual(LPOST_16S_opt_1_annotated_results_Leaf,
                     label = "Significance",
                     y.position = "y.position",
                     tip.length = 0.01,
                     size = 10,
                     bracket.size = 2.5,
                     hide.ns = TRUE)

# Print the annotated plot for LEAF
print(LPOST_16S_opt_1_alpha_Leaf)


#Repeating with AOD ---------

# Filter the phyloseq object for LEAF data
ps_18_month_16S_Leaf_AOD <- subset_samples(ps_18_month_16S, Organ == "LEAF")

# Estimate Shannon diversity for the LEAF subset
diversity_data_Leaf_AOD <- estimate_richness(ps_18_month_16S_Leaf_AOD, measures = c("Shannon"))

# Convert phyloseq sample_data for LEAF to dataframe
LPOST_16S_opt_1_df_16S_Leaf_AOD <- as(sample_data(ps_18_month_16S_Leaf_AOD), "data.frame")

# Add Shannon diversity to the LEAF dataframe
LPOST_16S_opt_1_df_16S_Leaf_AOD$Shannon <- diversity_data_Leaf_AOD$Shannon

# Reshape data for Shannon diversity index only
LPOST_16S_opt_1_df_long_Leaf_AOD <- LPOST_16S_opt_1_df_16S_Leaf_AOD %>%
  pivot_longer(cols = "Shannon", 
               names_to = "Diversity_Index", 
               values_to = "Value")

# Create plot with AOD on x-axis and faceting by Treatment (for LEAF only)
LPOST_16S_opt_1_alpha_Leaf_AOD <- ggplot(LPOST_16S_opt_1_df_long_Leaf_AOD, aes(x = AOD, y = Value, fill = AOD)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  facet_wrap(~ Treatment, scales = "free_y", 
             labeller = labeller(Treatment = c(
               "C" = "Control",
               "D" = "Rain Exclusion",
               "R" = "Ringbarked"
             ))) +  # Map labels for Treatment
  labs(x = NULL, y = "Shannon Diversity Index") +  # Label change
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  scale_fill_manual(
    values = c("N" = "#4C4CFF", "Y" = "#FF4C4C"), # Colorblind-friendly colors
    labels = c("N" = "No AOD", "Y" = "With AOD")
  )

# Print the plot
print(LPOST_16S_opt_1_alpha_Leaf_AOD)

# Perform Kruskal-Wallis test grouped by Treatment and AOD for LEAF
LPOST_16S_opt_1_kruskal_results_Leaf_AOD <- LPOST_16S_opt_1_df_long_Leaf_AOD %>%
  group_by(Treatment) %>%
  summarise(
    test_result = list(kruskal.test(Value ~ AOD, data = cur_data())),
    .groups = "drop"
  )

# Extract and print Kruskal-Wallis p-values for LEAF
LPOST_16S_opt_1_kruskal_results_Leaf_AOD <- LPOST_16S_opt_1_kruskal_results_Leaf_AOD %>%
  rowwise() %>%
  mutate(p_value = test_result$p.value) %>%
  select(Treatment, p_value)
print(LPOST_16S_opt_1_kruskal_results_Leaf_AOD)

# Perform pairwise Wilcoxon rank-sum test grouped by Treatment and AOD for LEAF
LPOST_16S_opt_1_wilcoxon_results_Leaf_AOD <- LPOST_16S_opt_1_df_long_Leaf_AOD %>%
  group_by(Treatment) %>%
  pairwise_wilcox_test(Value ~ AOD, p.adjust.method = "bonferroni")

# Add significance annotations
LPOST_16S_opt_1_annotated_results_Leaf_AOD <- LPOST_16S_opt_1_wilcoxon_results_Leaf_AOD %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Calculate maximum y-values for placement of annotations for LEAF
LPOST_16S_opt_1_max_y_Leaf_AOD <- LPOST_16S_opt_1_df_long_Leaf_AOD %>%
  group_by(Treatment, AOD) %>%
  summarize(max_value = max(Value, na.rm = TRUE)) %>%
  ungroup()

# Ensure that AOD is included in the Wilcoxon test results
LPOST_16S_opt_1_wilcoxon_results_Leaf_with_AOD <- LPOST_16S_opt_1_wilcoxon_results_Leaf_AOD %>%
  left_join(LPOST_16S_opt_1_df_long_Leaf_AOD %>% select(Treatment, AOD) %>% distinct(), by = "Treatment")

# Add significance annotations based on adjusted p-values
LPOST_16S_opt_1_wilcoxon_results_Leaf_with_AOD <- LPOST_16S_opt_1_wilcoxon_results_Leaf_with_AOD %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Now merge the max_value from LPOST_16S_opt_1_max_y_Leaf into the Wilcoxon test results
LPOST_16S_opt_1_annotated_results_Leaf_AOD <- LPOST_16S_opt_1_wilcoxon_results_Leaf_with_AOD %>%
  left_join(LPOST_16S_opt_1_max_y_Leaf_AOD, by = c("Treatment", "AOD"))

# Add y.position for annotation (e.g., adding 0.1 to max_value for visual placement)
LPOST_16S_opt_1_annotated_results_Leaf_AOD <- LPOST_16S_opt_1_annotated_results_Leaf_AOD %>%
  mutate(y.position = max_value + 0.1) %>%
  filter(row_number() %% 2 == 1)  # Keeps only every other row


# Now you can safely add the significance annotations to the plot
LPOST_16S_opt_1_alpha_Leaf_AOD <- LPOST_16S_opt_1_alpha_Leaf_AOD +
  stat_pvalue_manual(LPOST_16S_opt_1_annotated_results_Leaf_AOD,
                     label = "Significance",
                     y.position = "y.position",
                     tip.length = 0.01,
                     size = 10,
                     bracket.size = 2.5,
                     hide.ns = TRUE)

# Print the final plot with annotations for LEAF
print(LPOST_16S_opt_1_alpha_Leaf_AOD)


#-------------- repeating with Root --------------
# Filter the phyloseq object for ROOT data
ps_18_month_16S_ROOT <- subset_samples(ps_18_month_16S, Organ == "ROOT")

# Estimate Shannon diversity for the ROOT subset
diversity_data_ROOT <- estimate_richness(ps_18_month_16S_ROOT, measures = c("Shannon"))

# Convert phyloseq sample_data for ROOT to dataframe
LPOST_16S_opt_1_df_16S_ROOT <- as(sample_data(ps_18_month_16S_ROOT), "data.frame")

# Add Shannon diversity to the ROOT dataframe
LPOST_16S_opt_1_df_16S_ROOT$Shannon <- diversity_data_ROOT$Shannon

# Reshape data for Shannon diversity index only
LPOST_16S_opt_1_df_long_ROOT <- LPOST_16S_opt_1_df_16S_ROOT %>%
  pivot_longer(cols = "Shannon", 
               names_to = "Diversity_Index", 
               values_to = "Value")

# Plot for Shannon diversity index in ROOT
LPOST_16S_opt_1_alpha_ROOT <- ggplot(LPOST_16S_opt_1_df_long_ROOT, aes(x = Treatment, y = Value, fill = Treatment)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  facet_wrap(~ AOD, scales = "free_y", 
             labeller = labeller(AOD = c("N" = "No AOD", "Y" = "With AOD"))) +  # Modify facet as needed
  labs(x = NULL, y = "Shannon Diversity Index") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  scale_fill_manual(
    values = c("C" = "#1F77B4", "D" = "#2CA02C", "R" = "#FF7F0E"), # Colorblind-friendly colors
    labels = c("C" = "Control", "D" = "Rain Exclusion", "R" = "Ringbarked")
  )

# Print the updated plot
print(LPOST_16S_opt_1_alpha_ROOT)

# Perform Kruskal-Wallis test for ROOT only
LPOST_16S_opt_1_kruskal_results_ROOT <- LPOST_16S_opt_1_df_long_ROOT %>%
  group_by(AOD) %>%
  summarise(
    test_result = list(kruskal.test(Value ~ Treatment, data = cur_data())),
    .groups = "drop"
  )

# Print Kruskal-Wallis results for ROOT
LPOST_16S_opt_1_kruskal_results_ROOT %>%
  rowwise() %>%
  mutate(p_value = test_result$p.value) %>%
  select(AOD, p_value)

# Perform Pairwise Wilcoxon test for Shannon Diversity for ROOT
LPOST_16S_opt_1_wilcoxon_results_ROOT <- LPOST_16S_opt_1_df_long_ROOT %>%
  group_by(AOD) %>%
  pairwise_wilcox_test(Value ~ Treatment, p.adjust.method = "bonferroni")

# Print the Wilcoxon test results for ROOT
print(LPOST_16S_opt_1_wilcoxon_results_ROOT)

# Add statistical significance annotations to your ROOT plot
LPOST_16S_opt_1_annotated_results_ROOT <- LPOST_16S_opt_1_wilcoxon_results_ROOT %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Calculate max_value and y.position for annotations
LPOST_16S_opt_1_max_y_ROOT <- LPOST_16S_opt_1_df_long_ROOT %>%
  group_by(AOD, Treatment) %>%
  summarize(max_value = max(Value, na.rm = TRUE)) %>%
  ungroup()

LPOST_16S_opt_1_annotated_results_ROOT$max_value <- LPOST_16S_opt_1_max_y_ROOT$max_value
LPOST_16S_opt_1_annotated_results_ROOT$Treatment <- LPOST_16S_opt_1_max_y_ROOT$Treatment

LPOST_16S_opt_1_annotated_results_ROOT <- LPOST_16S_opt_1_annotated_results_ROOT %>%
  mutate(y.position = max_value + 0.1)

# Add p-value annotations to the plot
LPOST_16S_opt_1_alpha_ROOT <- LPOST_16S_opt_1_alpha_ROOT +
  stat_pvalue_manual(LPOST_16S_opt_1_annotated_results_ROOT,
                     label = "Significance",
                     y.position = "y.position",
                     tip.length = 0.01,
                     size = 10,
                     bracket.size = 2.5,
                     hide.ns = TRUE)

# Print the annotated plot for ROOT
print(LPOST_16S_opt_1_alpha_ROOT)


#Repeating with AOD ---------
# Filter the phyloseq object for ROOT data
ps_18_month_16S_ROOT <- subset_samples(ps_18_month_16S, Organ == "ROOT")

# Estimate Shannon diversity for the ROOT subset
diversity_data_ROOT <- estimate_richness(ps_18_month_16S_ROOT, measures = c("Shannon"))

# Convert phyloseq sample_data for ROOT to dataframe
LPOST_16S_opt_1_df_16S_ROOT <- as(sample_data(ps_18_month_16S_ROOT), "data.frame")

# Add Shannon diversity to the ROOT dataframe
LPOST_16S_opt_1_df_16S_ROOT$Shannon <- diversity_data_ROOT$Shannon

# Reshape data for Shannon diversity index only
LPOST_16S_opt_1_df_long_ROOT <- LPOST_16S_opt_1_df_16S_ROOT %>%
  pivot_longer(cols = "Shannon", 
               names_to = "Diversity_Index", 
               values_to = "Value")

# Create plot with AOD on x-axis and faceting by Treatment (for ROOT only)
LPOST_16S_opt_1_alpha_ROOT_AOD <- ggplot(LPOST_16S_opt_1_df_long_ROOT, aes(x = AOD, y = Value, fill = AOD)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  facet_wrap(~ Treatment, scales = "free_y", 
             labeller = labeller(Treatment = c(
               "C" = "Control",
               "D" = "Rain Exclusion",
               "R" = "Ringbarked"
             ))) +  # Map labels for Treatment
  labs(x = NULL, y = "Shannon Diversity Index") +  # Label change
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  scale_fill_manual(
    values = c("N" = "#4C4CFF", "Y" = "#FF4C4C"), # Colorblind-friendly colors
    labels = c("N" = "No AOD", "Y" = "With AOD")
  )

# Print the plot
print(LPOST_16S_opt_1_alpha_ROOT_AOD)

# Perform Kruskal-Wallis test grouped by Treatment and AOD for ROOT
LPOST_16S_opt_1_kruskal_results_ROOT <- LPOST_16S_opt_1_df_long_ROOT %>%
  group_by(Treatment) %>%
  summarise(
    test_result = list(kruskal.test(Value ~ AOD, data = cur_data())),
    .groups = "drop"
  )

# Extract and print Kruskal-Wallis p-values for ROOT
LPOST_16S_opt_1_kruskal_results_ROOT <- LPOST_16S_opt_1_kruskal_results_ROOT %>%
  rowwise() %>%
  mutate(p_value = test_result$p.value) %>%
  select(Treatment, p_value)
print(LPOST_16S_opt_1_kruskal_results_ROOT)

# Perform pairwise Wilcoxon rank-sum test grouped by Treatment and AOD for ROOT
LPOST_16S_opt_1_wilcoxon_results_ROOT <- LPOST_16S_opt_1_df_long_ROOT %>%
  group_by(Treatment) %>%
  pairwise_wilcox_test(Value ~ AOD, p.adjust.method = "bonferroni")

# Add significance annotations
LPOST_16S_opt_1_annotated_results_ROOT <- LPOST_16S_opt_1_wilcoxon_results_ROOT %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Calculate maximum y-values for placement of annotations for ROOT
LPOST_16S_opt_1_max_y_ROOT <- LPOST_16S_opt_1_df_long_ROOT %>%
  group_by(Treatment, AOD) %>%
  summarize(max_value = max(Value, na.rm = TRUE)) %>%
  ungroup()

# Ensure that AOD is included in the Wilcoxon test results
LPOST_16S_opt_1_wilcoxon_results_ROOT_with_AOD <- LPOST_16S_opt_1_wilcoxon_results_ROOT %>%
  left_join(LPOST_16S_opt_1_df_long_ROOT %>% select(Treatment, AOD) %>% distinct(), by = "Treatment")

# Add significance annotations based on adjusted p-values
LPOST_16S_opt_1_wilcoxon_results_ROOT_with_AOD <- LPOST_16S_opt_1_wilcoxon_results_ROOT_with_AOD %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Now merge the max_value from LPOST_16S_opt_1_max_y_ROOT into the Wilcoxon test results
LPOST_16S_opt_1_annotated_results_ROOT <- LPOST_16S_opt_1_wilcoxon_results_ROOT_with_AOD %>%
  left_join(LPOST_16S_opt_1_max_y_ROOT, by = c("Treatment", "AOD"))

# Add y.position for annotation (e.g., adding 0.1 to max_value for visual placement)
LPOST_16S_opt_1_annotated_results_ROOT <- LPOST_16S_opt_1_annotated_results_ROOT %>%
  mutate(y.position = max_value + 0.1) %>%
  filter(row_number() %% 2 == 1)  # Keeps only every other row


# Now you can safely add the significance annotations to the plot
LPOST_16S_opt_1_alpha_ROOT_AOD <- LPOST_16S_opt_1_alpha_ROOT_AOD +
  stat_pvalue_manual(LPOST_16S_opt_1_annotated_results_ROOT,
                     label = "Significance",
                     y.position = "y.position",
                     tip.length = 0.01,
                     size = 10,
                     bracket.size = 2.5,
                     hide.ns = TRUE)

# Print the final plot with annotations for ROOT
print(LPOST_16S_opt_1_alpha_ROOT_AOD)
```

#Alpha diversity - Time point 3 - ITS
```{r}
# Filter the phyloseq object for STEM data
ps_6_month_ITS_STEM <- subset_samples(ps_6_month_ITS, Organ == "STEM")

# Estimate Shannon diversity for the STEM subset
diversity_data_STEM <- estimate_richness(ps_6_month_ITS_STEM, measures = c("Shannon"))

# Convert phyloseq sample_data for STEM to dataframe
POST_ITS_opt_1_df_ITS_STEM <- as(sample_data(ps_6_month_ITS_STEM), "data.frame")

# Add Shannon diversity to the STEM dataframe
POST_ITS_opt_1_df_ITS_STEM$Shannon <- diversity_data_STEM$Shannon

# Reshape data for Shannon diversity index only
POST_ITS_opt_1_df_long_STEM <- POST_ITS_opt_1_df_ITS_STEM %>%
  pivot_longer(cols = "Shannon", 
               names_to = "Diversity_Index", 
               values_to = "Value")

# Plot for Shannon diversity index in STEM
POST_ITS_opt_1_alpha_STEM <- ggplot(POST_ITS_opt_1_df_long_STEM, aes(x = Treatment, y = Value, fill = Treatment)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  facet_wrap(~ AOD, scales = "free_y", 
             labeller = labeller(AOD = c("N" = "No AOD", "Y" = "With AOD"))) +  # Modify facet as needed
  labs(x = NULL, y = "Shannon Diversity Index") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  scale_fill_manual(
    values = c("C" = "#1F77B4", "D" = "#2CA02C", "R" = "#FF7F0E"), # Colorblind-friendly colors
    labels = c("C" = "Control", "D" = "Rain Exclusion", "R" = "Ringbarked")
  )

# Print the updated plot
print(POST_ITS_opt_1_alpha_STEM)

# Perform Kruskal-Wallis test for STEM only
POST_ITS_opt_1_kruskal_results_STEM <- POST_ITS_opt_1_df_long_STEM %>%
  group_by(AOD) %>%
  summarise(
    test_result = list(kruskal.test(Value ~ Treatment, data = cur_data())),
    .groups = "drop"
  )

# Print Kruskal-Wallis results for STEM
POST_ITS_opt_1_kruskal_results_STEM %>%
  rowwise() %>%
  mutate(p_value = test_result$p.value) %>%
  select(AOD, p_value)

# Perform Pairwise Wilcoxon test for Shannon Diversity for STEM
POST_ITS_opt_1_wilcoxon_results_STEM <- POST_ITS_opt_1_df_long_STEM %>%
  group_by(AOD) %>%
  pairwise_wilcox_test(Value ~ Treatment, p.adjust.method = "bonferroni")

# Print the Wilcoxon test results for STEM
print(POST_ITS_opt_1_wilcoxon_results_STEM)

# Add statistical significance annotations to your STEM plot
POST_ITS_opt_1_annotated_results_STEM <- POST_ITS_opt_1_wilcoxon_results_STEM %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Calculate max_value and y.position for annotations
POST_ITS_opt_1_max_y_STEM <- POST_ITS_opt_1_df_long_STEM %>%
  group_by(AOD, Treatment) %>%
  summarize(max_value = max(Value, na.rm = TRUE)) %>%
  ungroup()

POST_ITS_opt_1_annotated_results_STEM$max_value <- POST_ITS_opt_1_max_y_STEM$max_value
POST_ITS_opt_1_annotated_results_STEM$Treatment <- POST_ITS_opt_1_max_y_STEM$Treatment

POST_ITS_opt_1_annotated_results_STEM <- POST_ITS_opt_1_annotated_results_STEM %>%
  mutate(y.position = max_value + 0.1)

# Add p-value annotations to the plot
POST_ITS_opt_1_alpha_STEM <- POST_ITS_opt_1_alpha_STEM +
  stat_pvalue_manual(POST_ITS_opt_1_annotated_results_STEM,
                     label = "Significance",
                     y.position = "y.position",
                     tip.length = 0.01,
                     size = 10,
                     bracket.size = 2.5,
                     hide.ns = TRUE)

# Print the annotated plot for STEM
print(POST_ITS_opt_1_alpha_STEM)


#Repeating with AOD ---------
# Filter the phyloseq object for STEM data
ps_6_month_ITS_STEM_AOD <- subset_samples(ps_6_month_ITS, Organ == "STEM")

# Estimate Shannon diversity for the STEM subset
diversity_data_STEM_AOD <- estimate_richness(ps_6_month_ITS_STEM_AOD, measures = c("Shannon"))

# Convert phyloseq sample_data for STEM to dataframe
POST_ITS_opt_1_df_ITS_STEM_AOD <- as(sample_data(ps_6_month_ITS_STEM_AOD), "data.frame")

# Add Shannon diversity to the STEM dataframe
POST_ITS_opt_1_df_ITS_STEM_AOD$Shannon <- diversity_data_STEM_AOD$Shannon

# Reshape data for Shannon diversity index only
POST_ITS_opt_1_df_long_STEM_AOD <- POST_ITS_opt_1_df_ITS_STEM_AOD %>%
  pivot_longer(cols = "Shannon", 
               names_to = "Diversity_Index", 
               values_to = "Value")

# Create plot with AOD on x-axis and faceting by Treatment (for STEM only)
POST_ITS_opt_1_alpha_STEM_AOD <- ggplot(POST_ITS_opt_1_df_long_STEM_AOD, aes(x = AOD, y = Value, fill = AOD)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  facet_wrap(~ Treatment, scales = "free_y", 
             labeller = labeller(Treatment = c(
               "C" = "Control",
               "D" = "Rain Exclusion",
               "R" = "Ringbarked"
             ))) +  # Map labels for Treatment
  labs(x = NULL, y = "Shannon Diversity Index") +  # Label change
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  scale_fill_manual(
    values = c("N" = "#4C4CFF", "Y" = "#FF4C4C"), # Colorblind-friendly colors
    labels = c("N" = "No AOD", "Y" = "With AOD")
  )

# Print the plot
print(POST_ITS_opt_1_alpha_STEM_AOD)

# Perform Kruskal-Wallis test grouped by Treatment and AOD for STEM
POST_ITS_opt_1_kruskal_results_STEM_AOD <- POST_ITS_opt_1_df_long_STEM_AOD %>%
  group_by(Treatment) %>%
  summarise(
    test_result = list(kruskal.test(Value ~ AOD, data = cur_data())),
    .groups = "drop"
  )

# Extract and print Kruskal-Wallis p-values for STEM
POST_ITS_opt_1_kruskal_results_STEM_AOD <- POST_ITS_opt_1_kruskal_results_STEM_AOD %>%
  rowwise() %>%
  mutate(p_value = test_result$p.value) %>%
  select(Treatment, p_value)
print(POST_ITS_opt_1_kruskal_results_STEM_AOD)

# Perform pairwise Wilcoxon rank-sum test grouped by Treatment and AOD for STEM
POST_ITS_opt_1_wilcoxon_results_STEM_AOD <- POST_ITS_opt_1_df_long_STEM_AOD %>%
  group_by(Treatment) %>%
  pairwise_wilcox_test(Value ~ AOD, p.adjust.method = "bonferroni")

# Add significance annotations
POST_ITS_opt_1_annotated_results_STEM_AOD <- POST_ITS_opt_1_wilcoxon_results_STEM_AOD %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Calculate maximum y-values for placement of annotations for STEM
POST_ITS_opt_1_max_y_STEM_AOD <- POST_ITS_opt_1_df_long_STEM_AOD %>%
  group_by(Treatment, AOD) %>%
  summarize(max_value = max(Value, na.rm = TRUE)) %>%
  ungroup()

# Ensure that AOD is included in the Wilcoxon test results
POST_ITS_opt_1_wilcoxon_results_STEM_with_AOD <- POST_ITS_opt_1_wilcoxon_results_STEM_AOD %>%
  left_join(POST_ITS_opt_1_df_long_STEM_AOD %>% select(Treatment, AOD) %>% distinct(), by = "Treatment")

# Add significance annotations based on adjusted p-values
POST_ITS_opt_1_wilcoxon_results_STEM_with_AOD <- POST_ITS_opt_1_wilcoxon_results_STEM_with_AOD %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Now merge the max_value from POST_ITS_opt_1_max_y_STEM into the Wilcoxon test results
POST_ITS_opt_1_annotated_results_STEM_AOD <- POST_ITS_opt_1_wilcoxon_results_STEM_with_AOD %>%
  left_join(POST_ITS_opt_1_max_y_STEM_AOD, by = c("Treatment", "AOD"))

# Add y.position for annotation (e.g., adding 0.1 to max_value for visual placement)
POST_ITS_opt_1_annotated_results_STEM_AOD <- POST_ITS_opt_1_annotated_results_STEM_AOD %>%
  mutate(y.position = max_value + 0.1) %>%
  filter(row_number() %% 2 == 1)  # Keeps only every other row



# Now you can safely add the significance annotations to the plot
POST_ITS_opt_1_alpha_STEM_AOD <- POST_ITS_opt_1_alpha_STEM_AOD +
  stat_pvalue_manual(POST_ITS_opt_1_annotated_results_STEM_AOD,
                     label = "Significance",
                     y.position = "y.position",
                     tip.length = 0.01,
                     size = 10,
                     bracket.size = 2.5,
                     hide.ns = TRUE)

# Print the final plot with annotations for STEM
print(POST_ITS_opt_1_alpha_STEM_AOD)

#-------------- Repeat with ROOT  -----------------
# Filter the phyloseq object for ROOT data
ps_6_month_ITS_ROOT <- subset_samples(ps_6_month_ITS, Organ == "ROOT")

# Estimate Shannon diversity for the ROOT subset
diversity_data_ROOT <- estimate_richness(ps_6_month_ITS_ROOT, measures = c("Shannon"))

# Convert phyloseq sample_data for ROOT to dataframe
POST_ITS_opt_1_df_ITS_ROOT <- as(sample_data(ps_6_month_ITS_ROOT), "data.frame")

# Add Shannon diversity to the ROOT dataframe
POST_ITS_opt_1_df_ITS_ROOT$Shannon <- diversity_data_ROOT$Shannon

# Reshape data for Shannon diversity index only
POST_ITS_opt_1_df_long_ROOT <- POST_ITS_opt_1_df_ITS_ROOT %>%
  pivot_longer(cols = "Shannon", 
               names_to = "Diversity_Index", 
               values_to = "Value")

# Plot for Shannon diversity index in ROOT
POST_ITS_opt_1_alpha_ROOT <- ggplot(POST_ITS_opt_1_df_long_ROOT, aes(x = Treatment, y = Value, fill = Treatment)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  facet_wrap(~ AOD, scales = "free_y", 
             labeller = labeller(AOD = c("N" = "No AOD", "Y" = "With AOD"))) +  # Modify facet as needed
  labs(x = NULL, y = "Shannon Diversity Index") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  scale_fill_manual(
    values = c("C" = "#1F77B4", "D" = "#2CA02C", "R" = "#FF7F0E"), # Colorblind-friendly colors
    labels = c("C" = "Control", "D" = "Rain Exclusion", "R" = "Ringbarked")
  )

# Print the updated plot
print(POST_ITS_opt_1_alpha_ROOT)

# Perform Kruskal-Wallis test for ROOT only
POST_ITS_opt_1_kruskal_results_ROOT <- POST_ITS_opt_1_df_long_ROOT %>%
  group_by(AOD) %>%
  summarise(
    test_result = list(kruskal.test(Value ~ Treatment, data = cur_data())),
    .groups = "drop"
  )

# Print Kruskal-Wallis results for ROOT
POST_ITS_opt_1_kruskal_results_ROOT %>%
  rowwise() %>%
  mutate(p_value = test_result$p.value) %>%
  select(AOD, p_value)

# Perform Pairwise Wilcoxon test for Shannon Diversity for ROOT
POST_ITS_opt_1_wilcoxon_results_ROOT <- POST_ITS_opt_1_df_long_ROOT %>%
  group_by(AOD) %>%
  pairwise_wilcox_test(Value ~ Treatment, p.adjust.method = "bonferroni")

# Print the Wilcoxon test results for ROOT
print(POST_ITS_opt_1_wilcoxon_results_ROOT)

# Add statistical significance annotations to your ROOT plot
POST_ITS_opt_1_annotated_results_ROOT <- POST_ITS_opt_1_wilcoxon_results_ROOT %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Calculate max_value and y.position for annotations
POST_ITS_opt_1_max_y_ROOT <- POST_ITS_opt_1_df_long_ROOT %>%
  group_by(AOD, Treatment) %>%
  summarize(max_value = max(Value, na.rm = TRUE)) %>%
  ungroup()

POST_ITS_opt_1_annotated_results_ROOT$max_value <- POST_ITS_opt_1_max_y_ROOT$max_value
POST_ITS_opt_1_annotated_results_ROOT$Treatment <- POST_ITS_opt_1_max_y_ROOT$Treatment

POST_ITS_opt_1_annotated_results_ROOT <- POST_ITS_opt_1_annotated_results_ROOT %>%
  mutate(y.position = max_value + 0.1)

# Add p-value annotations to the plot
POST_ITS_opt_1_alpha_ROOT <- POST_ITS_opt_1_alpha_ROOT +
  stat_pvalue_manual(POST_ITS_opt_1_annotated_results_ROOT,
                     label = "Significance",
                     y.position = "y.position",
                     tip.length = 0.01,
                     size = 10,
                     bracket.size = 2.5,
                     hide.ns = TRUE)

# Print the annotated plot for ROOT
print(POST_ITS_opt_1_alpha_ROOT)


#Repeating with AOD ---------

# Filter the phyloseq object for ROOT data
ps_6_month_ITS_ROOT_AOD <- subset_samples(ps_6_month_ITS, Organ == "ROOT")

# Estimate Shannon diversity for the ROOT subset
diversity_data_ROOT_AOD <- estimate_richness(ps_6_month_ITS_ROOT_AOD, measures = c("Shannon"))

# Convert phyloseq sample_data for ROOT to dataframe
POST_ITS_opt_1_df_ITS_ROOT_AOD <- as(sample_data(ps_6_month_ITS_ROOT_AOD), "data.frame")

# Add Shannon diversity to the ROOT dataframe
POST_ITS_opt_1_df_ITS_ROOT_AOD$Shannon <- diversity_data_ROOT_AOD$Shannon

# Reshape data for Shannon diversity index only
POST_ITS_opt_1_df_long_ROOT_AOD <- POST_ITS_opt_1_df_ITS_ROOT_AOD %>%
  pivot_longer(cols = "Shannon", 
               names_to = "Diversity_Index", 
               values_to = "Value")

# Create plot with AOD on x-axis and faceting by Treatment (for ROOT only)
POST_ITS_opt_1_alpha_ROOT_AOD <- ggplot(POST_ITS_opt_1_df_long_ROOT_AOD, aes(x = AOD, y = Value, fill = AOD)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  facet_wrap(~ Treatment, scales = "free_y", 
             labeller = labeller(Treatment = c(
               "C" = "Control",
               "D" = "Rain Exclusion",
               "R" = "Ringbarked"
             ))) +  # Map labels for Treatment
  labs(x = NULL, y = "Shannon Diversity Index") +  # Label change
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  scale_fill_manual(
    values = c("N" = "#4C4CFF", "Y" = "#FF4C4C"), # Colorblind-friendly colors
    labels = c("N" = "No AOD", "Y" = "With AOD")
  )

# Print the plot
print(POST_ITS_opt_1_alpha_ROOT_AOD)

# Perform Kruskal-Wallis test grouped by Treatment and AOD for ROOT
POST_ITS_opt_1_kruskal_results_ROOT_AOD <- POST_ITS_opt_1_df_long_ROOT_AOD %>%
  group_by(Treatment) %>%
  summarise(
    test_result = list(kruskal.test(Value ~ AOD, data = cur_data())),
    .groups = "drop"
  )

# Extract and print Kruskal-Wallis p-values for ROOT
POST_ITS_opt_1_kruskal_results_ROOT_AOD <- POST_ITS_opt_1_kruskal_results_ROOT_AOD %>%
  rowwise() %>%
  mutate(p_value = test_result$p.value) %>%
  select(Treatment, p_value)
print(POST_ITS_opt_1_kruskal_results_ROOT_AOD)

# Perform pairwise Wilcoxon rank-sum test grouped by Treatment and AOD for ROOT
POST_ITS_opt_1_wilcoxon_results_ROOT_AOD <- POST_ITS_opt_1_df_long_ROOT_AOD %>%
  group_by(Treatment) %>%
  pairwise_wilcox_test(Value ~ AOD, p.adjust.method = "bonferroni")

# Add significance annotations
POST_ITS_opt_1_annotated_results_ROOT_AOD <- POST_ITS_opt_1_wilcoxon_results_ROOT_AOD %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Calculate maximum y-values for placement of annotations for ROOT
POST_ITS_opt_1_max_y_ROOT_AOD <- POST_ITS_opt_1_df_long_ROOT_AOD %>%
  group_by(Treatment, AOD) %>%
  summarize(max_value = max(Value, na.rm = TRUE)) %>%
  ungroup()

# Ensure that AOD is included in the Wilcoxon test results
POST_ITS_opt_1_wilcoxon_results_ROOT_with_AOD <- POST_ITS_opt_1_wilcoxon_results_ROOT_AOD %>%
  left_join(POST_ITS_opt_1_df_long_ROOT_AOD %>% select(Treatment, AOD) %>% distinct(), by = "Treatment")

# Add significance annotations based on adjusted p-values
POST_ITS_opt_1_wilcoxon_results_ROOT_with_AOD <- POST_ITS_opt_1_wilcoxon_results_ROOT_with_AOD %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Now merge the max_value from POST_ITS_opt_1_max_y_ROOT into the Wilcoxon test results
POST_ITS_opt_1_annotated_results_ROOT_AOD <- POST_ITS_opt_1_wilcoxon_results_ROOT_with_AOD %>%
  left_join(POST_ITS_opt_1_max_y_ROOT_AOD, by = c("Treatment", "AOD"))

# Add y.position for annotation (e.g., adding 0.1 to max_value for visual placement)
POST_ITS_opt_1_annotated_results_ROOT_AOD <- POST_ITS_opt_1_annotated_results_ROOT_AOD %>%
  mutate(y.position = max_value + 0.1)

# Now you can safely add the significance annotations to the plot
POST_ITS_opt_1_alpha_ROOT_AOD <- POST_ITS_opt_1_alpha_ROOT_AOD +
  stat_pvalue_manual(POST_ITS_opt_1_annotated_results_ROOT_AOD,
                     label = "Significance",
                     y.position = "y.position",
                     tip.length = 0.01,
                     size = 10,
                     bracket.size = 2.5,
                     hide.ns = TRUE)

# Print the final plot with annotations for ROOT
print(POST_ITS_opt_1_alpha_ROOT_AOD)
```

#Alpha diversity - Time point 4 - ITS
```{r}
# Filter the phyloseq object for STEM data
ps_18_month_ITS_STEM <- subset_samples(ps_18_month_ITS, Organ == "STEM")

# Estimate Shannon diversity for the STEM subset
diversity_data_STEM <- estimate_richness(ps_18_month_ITS_STEM, measures = c("Shannon"))

# Convert phyloseq sample_data for STEM to dataframe
LPOST_ITS_opt_1_df_ITS_STEM <- as(sample_data(ps_18_month_ITS_STEM), "data.frame")

# Add Shannon diversity to the STEM dataframe
LPOST_ITS_opt_1_df_ITS_STEM$Shannon <- diversity_data_STEM$Shannon

# Reshape data for Shannon diversity index only
LPOST_ITS_opt_1_df_long_STEM <- LPOST_ITS_opt_1_df_ITS_STEM %>%
  pivot_longer(cols = "Shannon", 
               names_to = "Diversity_Index", 
               values_to = "Value")

# Plot for Shannon diversity index in STEM
LPOST_ITS_opt_1_alpha_STEM <- ggplot(LPOST_ITS_opt_1_df_long_STEM, aes(x = Treatment, y = Value, fill = Treatment)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  facet_wrap(~ AOD, scales = "free_y", 
             labeller = labeller(AOD = c("N" = "No AOD", "Y" = "With AOD"))) +  # Modify facet as needed
  labs(x = NULL, y = "Shannon Diversity Index") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  scale_fill_manual(
    values = c("C" = "#1F77B4", "D" = "#2CA02C", "R" = "#FF7F0E"), # Colorblind-friendly colors
    labels = c("C" = "Control", "D" = "Rain Exclusion", "R" = "Ringbarked")
  )

# Print the updated plot
print(LPOST_ITS_opt_1_alpha_STEM)

# Perform Kruskal-Wallis test for STEM only
LPOST_ITS_opt_1_kruskal_results_STEM <- LPOST_ITS_opt_1_df_long_STEM %>%
  group_by(AOD) %>%
  summarise(
    test_result = list(kruskal.test(Value ~ Treatment, data = cur_data())),
    .groups = "drop"
  )

# Print Kruskal-Wallis results for STEM
LPOST_ITS_opt_1_kruskal_results_STEM %>%
  rowwise() %>%
  mutate(p_value = test_result$p.value) %>%
  select(AOD, p_value)

# Perform Pairwise Wilcoxon test for Shannon Diversity for STEM
LPOST_ITS_opt_1_wilcoxon_results_STEM <- LPOST_ITS_opt_1_df_long_STEM %>%
  group_by(AOD) %>%
  pairwise_wilcox_test(Value ~ Treatment, p.adjust.method = "bonferroni")

# Print the Wilcoxon test results for STEM
print(LPOST_ITS_opt_1_wilcoxon_results_STEM)

# Add statistical significance annotations to your STEM plot
LPOST_ITS_opt_1_annotated_results_STEM <- LPOST_ITS_opt_1_wilcoxon_results_STEM %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Calculate max_value and y.position for annotations
LPOST_ITS_opt_1_max_y_STEM <- LPOST_ITS_opt_1_df_long_STEM %>%
  group_by(AOD, Treatment) %>%
  summarize(max_value = max(Value, na.rm = TRUE)) %>%
  ungroup()

LPOST_ITS_opt_1_annotated_results_STEM$max_value <- LPOST_ITS_opt_1_max_y_STEM$max_value
LPOST_ITS_opt_1_annotated_results_STEM$Treatment <- LPOST_ITS_opt_1_max_y_STEM$Treatment

LPOST_ITS_opt_1_annotated_results_STEM <- LPOST_ITS_opt_1_annotated_results_STEM %>%
  mutate(y.position = max_value + 0.1)

# Add p-value annotations to the plot
LPOST_ITS_opt_1_alpha_STEM <- LPOST_ITS_opt_1_alpha_STEM +
  stat_pvalue_manual(LPOST_ITS_opt_1_annotated_results_STEM,
                     label = "Significance",
                     y.position = "y.position",
                     tip.length = 0.01,
                     size = 10,
                     bracket.size = 2.5,
                     hide.ns = TRUE)

# Print the annotated plot for STEM
print(LPOST_ITS_opt_1_alpha_STEM)


#Repeating with AOD ---------
# Filter the phyloseq object for STEM data
ps_18_month_ITS_STEM_AOD <- subset_samples(ps_18_month_ITS, Organ == "STEM")

# Estimate Shannon diversity for the STEM subset
diversity_data_STEM_AOD <- estimate_richness(ps_18_month_ITS_STEM_AOD, measures = c("Shannon"))

# Convert phyloseq sample_data for STEM to dataframe
LPOST_ITS_opt_1_df_ITS_STEM_AOD <- as(sample_data(ps_18_month_ITS_STEM_AOD), "data.frame")

# Add Shannon diversity to the STEM dataframe
LPOST_ITS_opt_1_df_ITS_STEM_AOD$Shannon <- diversity_data_STEM_AOD$Shannon

# Reshape data for Shannon diversity index only
LPOST_ITS_opt_1_df_long_STEM_AOD <- LPOST_ITS_opt_1_df_ITS_STEM_AOD %>%
  pivot_longer(cols = "Shannon", 
               names_to = "Diversity_Index", 
               values_to = "Value")

# Create plot with AOD on x-axis and faceting by Treatment (for STEM only)
LPOST_ITS_opt_1_alpha_STEM_AOD <- ggplot(LPOST_ITS_opt_1_df_long_STEM_AOD, aes(x = AOD, y = Value, fill = AOD)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  facet_wrap(~ Treatment, scales = "free_y", 
             labeller = labeller(Treatment = c(
               "C" = "Control",
               "D" = "Rain Exclusion",
               "R" = "Ringbarked"
             ))) +  # Map labels for Treatment
  labs(x = NULL, y = "Shannon Diversity Index") +  # Label change
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  scale_fill_manual(
    values = c("N" = "#4C4CFF", "Y" = "#FF4C4C"), # Colorblind-friendly colors
    labels = c("N" = "No AOD", "Y" = "With AOD")
  )

# Print the plot
print(LPOST_ITS_opt_1_alpha_STEM_AOD)

# Perform Kruskal-Wallis test grouped by Treatment and AOD for STEM
LPOST_ITS_opt_1_kruskal_results_STEM_AOD <- LPOST_ITS_opt_1_df_long_STEM_AOD %>%
  group_by(Treatment) %>%
  summarise(
    test_result = list(kruskal.test(Value ~ AOD, data = cur_data())),
    .groups = "drop"
  )

# Extract and print Kruskal-Wallis p-values for STEM
LPOST_ITS_opt_1_kruskal_results_STEM_AOD <- LPOST_ITS_opt_1_kruskal_results_STEM_AOD %>%
  rowwise() %>%
  mutate(p_value = test_result$p.value) %>%
  select(Treatment, p_value)
print(LPOST_ITS_opt_1_kruskal_results_STEM_AOD)

# Perform pairwise Wilcoxon rank-sum test grouped by Treatment and AOD for STEM
LPOST_ITS_opt_1_wilcoxon_results_STEM_AOD <- LPOST_ITS_opt_1_df_long_STEM_AOD %>%
  group_by(Treatment) %>%
  pairwise_wilcox_test(Value ~ AOD, p.adjust.method = "bonferroni")

# Add significance annotations
LPOST_ITS_opt_1_annotated_results_STEM_AOD <- LPOST_ITS_opt_1_wilcoxon_results_STEM_AOD %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Calculate maximum y-values for placement of annotations for STEM
LPOST_ITS_opt_1_max_y_STEM_AOD <- LPOST_ITS_opt_1_df_long_STEM_AOD %>%
  group_by(Treatment, AOD) %>%
  summarize(max_value = max(Value, na.rm = TRUE)) %>%
  ungroup()

# Ensure that AOD is included in the Wilcoxon test results
LPOST_ITS_opt_1_wilcoxon_results_STEM_with_AOD <- LPOST_ITS_opt_1_wilcoxon_results_STEM_AOD %>%
  left_join(LPOST_ITS_opt_1_df_long_STEM_AOD %>% select(Treatment, AOD) %>% distinct(), by = "Treatment")

# Add significance annotations based on adjusted p-values
LPOST_ITS_opt_1_wilcoxon_results_STEM_with_AOD <- LPOST_ITS_opt_1_wilcoxon_results_STEM_with_AOD %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Now merge the max_value from LPOST_ITS_opt_1_max_y_STEM into the Wilcoxon test results
LPOST_ITS_opt_1_annotated_results_STEM_AOD <- LPOST_ITS_opt_1_wilcoxon_results_STEM_with_AOD %>%
  left_join(LPOST_ITS_opt_1_max_y_STEM_AOD, by = c("Treatment", "AOD"))

# Add y.position for annotation (e.g., adding 0.1 to max_value for visual placement)
LPOST_ITS_opt_1_annotated_results_STEM_AOD <- LPOST_ITS_opt_1_annotated_results_STEM_AOD %>%
  mutate(y.position = max_value + 0.1) %>%
  filter(row_number() %% 2 == 1)  # Keeps only every other row


# Now you can safely add the significance annotations to the plot
LPOST_ITS_opt_1_alpha_STEM_AOD <- LPOST_ITS_opt_1_alpha_STEM_AOD +
  stat_pvalue_manual(LPOST_ITS_opt_1_annotated_results_STEM_AOD,
                     label = "Significance",
                     y.position = "y.position",
                     tip.length = 0.01,
                     size = 10,
                     bracket.size = 2.5,
                     hide.ns = TRUE)

# Print the final plot with annotations for STEM
print(LPOST_ITS_opt_1_alpha_STEM_AOD)

#Repeat with leaves ---------------
# Filter the phyloseq object for LEAF data
ps_18_month_ITS_Leaf <- subset_samples(ps_18_month_ITS, Organ == "LEAF")

# Estimate Shannon diversity for the LEAF subset
diversity_data_Leaf <- estimate_richness(ps_18_month_ITS_Leaf, measures = c("Shannon"))

# Convert phyloseq sample_data for LEAF to dataframe
LPOST_ITS_opt_1_df_ITS_Leaf <- as(sample_data(ps_18_month_ITS_Leaf), "data.frame")

# Add Shannon diversity to the LEAF dataframe
LPOST_ITS_opt_1_df_ITS_Leaf$Shannon <- diversity_data_Leaf$Shannon

# Reshape data for Shannon diversity index only
LPOST_ITS_opt_1_df_long_Leaf <- LPOST_ITS_opt_1_df_ITS_Leaf %>%
  pivot_longer(cols = "Shannon", 
               names_to = "Diversity_Index", 
               values_to = "Value")

# Plot for Shannon diversity index in LEAF
LPOST_ITS_opt_1_alpha_Leaf <- ggplot(LPOST_ITS_opt_1_df_long_Leaf, aes(x = Treatment, y = Value, fill = Treatment)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  facet_wrap(~ AOD, scales = "free_y", 
             labeller = labeller(AOD = c("N" = "No AOD", "Y" = "With AOD"))) +  # Modify facet as needed
  labs(x = NULL, y = "Shannon Diversity Index") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  scale_fill_manual(
    values = c("C" = "#1F77B4", "D" = "#2CA02C", "R" = "#FF7F0E"), # Colorblind-friendly colors
    labels = c("C" = "Control", "D" = "Rain Exclusion", "R" = "Ringbarked")
  )

# Print the updated plot
print(LPOST_ITS_opt_1_alpha_Leaf)

# Perform Kruskal-Wallis test for LEAF only
LPOST_ITS_opt_1_kruskal_results_Leaf <- LPOST_ITS_opt_1_df_long_Leaf %>%
  group_by(AOD) %>%
  summarise(
    test_result = list(kruskal.test(Value ~ Treatment, data = cur_data())),
    .groups = "drop"
  )

# Print Kruskal-Wallis results for LEAF
LPOST_ITS_opt_1_kruskal_results_Leaf %>%
  rowwise() %>%
  mutate(p_value = test_result$p.value) %>%
  select(AOD, p_value)

# Perform Pairwise Wilcoxon test for Shannon Diversity for LEAF
LPOST_ITS_opt_1_wilcoxon_results_Leaf <- LPOST_ITS_opt_1_df_long_Leaf %>%
  group_by(AOD) %>%
  pairwise_wilcox_test(Value ~ Treatment, p.adjust.method = "bonferroni")

# Print the Wilcoxon test results for LEAF
print(LPOST_ITS_opt_1_wilcoxon_results_Leaf)

# Add statistical significance annotations to your LEAF plot
LPOST_ITS_opt_1_annotated_results_Leaf <- LPOST_ITS_opt_1_wilcoxon_results_Leaf %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Calculate max_value and y.position for annotations
LPOST_ITS_opt_1_max_y_Leaf <- LPOST_ITS_opt_1_df_long_Leaf %>%
  group_by(AOD, Treatment) %>%
  summarize(max_value = max(Value, na.rm = TRUE)) %>%
  ungroup()

LPOST_ITS_opt_1_annotated_results_Leaf$max_value <- LPOST_ITS_opt_1_max_y_Leaf$max_value
LPOST_ITS_opt_1_annotated_results_Leaf$Treatment <- LPOST_ITS_opt_1_max_y_Leaf$Treatment

LPOST_ITS_opt_1_annotated_results_Leaf <- LPOST_ITS_opt_1_annotated_results_Leaf %>%
  mutate(y.position = max_value + 0.1)

# Add p-value annotations to the plot
LPOST_ITS_opt_1_alpha_Leaf <- LPOST_ITS_opt_1_alpha_Leaf +
  stat_pvalue_manual(LPOST_ITS_opt_1_annotated_results_Leaf,
                     label = "Significance",
                     y.position = "y.position",
                     tip.length = 0.01,
                     size = 10,
                     bracket.size = 2.5,
                     hide.ns = TRUE)

# Print the annotated plot for LEAF
print(LPOST_ITS_opt_1_alpha_Leaf)


#Repeating with AOD ---------
# Filter the phyloseq object for LEAF data
ps_18_month_ITS_Leaf_AOD <- subset_samples(ps_18_month_ITS, Organ == "LEAF")

# Estimate Shannon diversity for the LEAF subset
diversity_data_Leaf_AOD <- estimate_richness(ps_18_month_ITS_Leaf_AOD, measures = c("Shannon"))

# Convert phyloseq sample_data for LEAF to dataframe
LPOST_ITS_opt_1_df_ITS_Leaf_AOD <- as(sample_data(ps_18_month_ITS_Leaf_AOD), "data.frame")

# Add Shannon diversity to the LEAF dataframe
LPOST_ITS_opt_1_df_ITS_Leaf_AOD$Shannon <- diversity_data_Leaf_AOD$Shannon

# Reshape data for Shannon diversity index only
LPOST_ITS_opt_1_df_long_Leaf_AOD <- LPOST_ITS_opt_1_df_ITS_Leaf_AOD %>%
  pivot_longer(cols = "Shannon", 
               names_to = "Diversity_Index", 
               values_to = "Value")

# Create plot with AOD on x-axis and faceting by Treatment (for LEAF only)
LPOST_ITS_opt_1_alpha_Leaf_AOD <- ggplot(LPOST_ITS_opt_1_df_long_Leaf_AOD, aes(x = AOD, y = Value, fill = AOD)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  facet_wrap(~ Treatment, scales = "free_y", 
             labeller = labeller(Treatment = c(
               "C" = "Control",
               "D" = "Rain Exclusion",
               "R" = "Ringbarked"
             ))) +  # Map labels for Treatment
  labs(x = NULL, y = "Shannon Diversity Index") +  # Label change
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  scale_fill_manual(
    values = c("N" = "#4C4CFF", "Y" = "#FF4C4C"), # Colorblind-friendly colors
    labels = c("N" = "No AOD", "Y" = "With AOD")
  )

# Print the plot
print(LPOST_ITS_opt_1_alpha_Leaf_AOD)

# Perform Kruskal-Wallis test grouped by Treatment and AOD for LEAF
LPOST_ITS_opt_1_kruskal_results_Leaf_AOD <- LPOST_ITS_opt_1_df_long_Leaf_AOD %>%
  group_by(Treatment) %>%
  summarise(
    test_result = list(kruskal.test(Value ~ AOD, data = cur_data())),
    .groups = "drop"
  )

# Extract and print Kruskal-Wallis p-values for LEAF
LPOST_ITS_opt_1_kruskal_results_Leaf_AOD <- LPOST_ITS_opt_1_kruskal_results_Leaf_AOD %>%
  rowwise() %>%
  mutate(p_value = test_result$p.value) %>%
  select(Treatment, p_value)
print(LPOST_ITS_opt_1_kruskal_results_Leaf_AOD)

# Perform pairwise Wilcoxon rank-sum test grouped by Treatment and AOD for LEAF
LPOST_ITS_opt_1_wilcoxon_results_Leaf_AOD <- LPOST_ITS_opt_1_df_long_Leaf_AOD %>%
  group_by(Treatment) %>%
  pairwise_wilcox_test(Value ~ AOD, p.adjust.method = "bonferroni")

# Add significance annotations
LPOST_ITS_opt_1_annotated_results_Leaf_AOD <- LPOST_ITS_opt_1_wilcoxon_results_Leaf_AOD %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Calculate maximum y-values for placement of annotations for LEAF
LPOST_ITS_opt_1_max_y_Leaf_AOD <- LPOST_ITS_opt_1_df_long_Leaf_AOD %>%
  group_by(Treatment, AOD) %>%
  summarize(max_value = max(Value, na.rm = TRUE)) %>%
  ungroup()

# Ensure that AOD is included in the Wilcoxon test results
LPOST_ITS_opt_1_wilcoxon_results_Leaf_with_AOD <- LPOST_ITS_opt_1_wilcoxon_results_Leaf_AOD %>%
  left_join(LPOST_ITS_opt_1_df_long_Leaf_AOD %>% select(Treatment, AOD) %>% distinct(), by = "Treatment")

# Add significance annotations based on adjusted p-values
LPOST_ITS_opt_1_wilcoxon_results_Leaf_with_AOD <- LPOST_ITS_opt_1_wilcoxon_results_Leaf_with_AOD %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Now merge the max_value from LPOST_ITS_opt_1_max_y_Leaf into the Wilcoxon test results
LPOST_ITS_opt_1_annotated_results_Leaf_AOD <- LPOST_ITS_opt_1_wilcoxon_results_Leaf_with_AOD %>%
  left_join(LPOST_ITS_opt_1_max_y_Leaf_AOD, by = c("Treatment", "AOD"))

# Add y.position for annotation (e.g., adding 0.1 to max_value for visual placement)
LPOST_ITS_opt_1_annotated_results_Leaf_AOD <- LPOST_ITS_opt_1_annotated_results_Leaf_AOD %>%
  mutate(y.position = max_value + 0.1) %>%
  filter(row_number() %% 2 == 1)  # Keeps only every other row


# Now you can safely add the significance annotations to the plot
LPOST_ITS_opt_1_alpha_Leaf_AOD <- LPOST_ITS_opt_1_alpha_Leaf_AOD +
  stat_pvalue_manual(LPOST_ITS_opt_1_annotated_results_Leaf_AOD,
                     label = "Significance",
                     y.position = "y.position",
                     tip.length = 0.01,
                     size = 10,
                     bracket.size = 2.5,
                     hide.ns = TRUE)

# Print the final plot with annotations for LEAF
print(LPOST_ITS_opt_1_alpha_Leaf_AOD)


#-------------- repeating with Root --------------


# Filter the phyloseq object for ROOT data
ps_18_month_ITS_ROOT <- subset_samples(ps_18_month_ITS, Organ == "ROOT")

# Estimate Shannon diversity for the ROOT subset
diversity_data_ROOT <- estimate_richness(ps_18_month_ITS_ROOT, measures = c("Shannon"))

# Convert phyloseq sample_data for ROOT to dataframe
LPOST_ITS_opt_1_df_ITS_ROOT <- as(sample_data(ps_18_month_ITS_ROOT), "data.frame")

# Add Shannon diversity to the ROOT dataframe
LPOST_ITS_opt_1_df_ITS_ROOT$Shannon <- diversity_data_ROOT$Shannon

# Reshape data for Shannon diversity index only
LPOST_ITS_opt_1_df_long_ROOT <- LPOST_ITS_opt_1_df_ITS_ROOT %>%
  pivot_longer(cols = "Shannon", 
               names_to = "Diversity_Index", 
               values_to = "Value")

# Plot for Shannon diversity index in ROOT
LPOST_ITS_opt_1_alpha_ROOT <- ggplot(LPOST_ITS_opt_1_df_long_ROOT, aes(x = Treatment, y = Value, fill = Treatment)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  facet_wrap(~ AOD, scales = "free_y", 
             labeller = labeller(AOD = c("N" = "No AOD", "Y" = "With AOD"))) +  # Modify facet as needed
  labs(x = NULL, y = "Shannon Diversity Index") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  scale_fill_manual(
    values = c("C" = "#1F77B4", "D" = "#2CA02C", "R" = "#FF7F0E"), # Colorblind-friendly colors
    labels = c("C" = "Control", "D" = "Rain Exclusion", "R" = "Ringbarked")
  )

# Print the updated plot
print(LPOST_ITS_opt_1_alpha_ROOT)

# Perform Kruskal-Wallis test for ROOT only
LPOST_ITS_opt_1_kruskal_results_ROOT <- LPOST_ITS_opt_1_df_long_ROOT %>%
  group_by(AOD) %>%
  summarise(
    test_result = list(kruskal.test(Value ~ Treatment, data = cur_data())),
    .groups = "drop"
  )

# Print Kruskal-Wallis results for ROOT
LPOST_ITS_opt_1_kruskal_results_ROOT %>%
  rowwise() %>%
  mutate(p_value = test_result$p.value) %>%
  select(AOD, p_value)

# Perform Pairwise Wilcoxon test for Shannon Diversity for ROOT
LPOST_ITS_opt_1_wilcoxon_results_ROOT <- LPOST_ITS_opt_1_df_long_ROOT %>%
  group_by(AOD) %>%
  pairwise_wilcox_test(Value ~ Treatment, p.adjust.method = "bonferroni")

# Print the Wilcoxon test results for ROOT
print(LPOST_ITS_opt_1_wilcoxon_results_ROOT)

# Add statistical significance annotations to your ROOT plot
LPOST_ITS_opt_1_annotated_results_ROOT <- LPOST_ITS_opt_1_wilcoxon_results_ROOT %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Calculate max_value and y.position for annotations
LPOST_ITS_opt_1_max_y_ROOT <- LPOST_ITS_opt_1_df_long_ROOT %>%
  group_by(AOD, Treatment) %>%
  summarize(max_value = max(Value, na.rm = TRUE)) %>%
  ungroup()

LPOST_ITS_opt_1_annotated_results_ROOT$max_value <- LPOST_ITS_opt_1_max_y_ROOT$max_value
LPOST_ITS_opt_1_annotated_results_ROOT$Treatment <- LPOST_ITS_opt_1_max_y_ROOT$Treatment

LPOST_ITS_opt_1_annotated_results_ROOT <- LPOST_ITS_opt_1_annotated_results_ROOT %>%
  mutate(y.position = max_value + 0.1)

# Add p-value annotations to the plot
LPOST_ITS_opt_1_alpha_ROOT <- LPOST_ITS_opt_1_alpha_ROOT +
  stat_pvalue_manual(LPOST_ITS_opt_1_annotated_results_ROOT,
                     label = "Significance",
                     y.position = "y.position",
                     tip.length = 0.01,
                     size = 10,
                     bracket.size = 2.5,
                     hide.ns = TRUE)

# Print the annotated plot for ROOT
print(LPOST_ITS_opt_1_alpha_ROOT)


#Repeating with AOD ---------

# Filter the phyloseq object for ROOT data
ps_18_month_ITS_ROOT_AOD <- subset_samples(ps_18_month_ITS, Organ == "ROOT")

# Estimate Shannon diversity for the ROOT subset
diversity_data_ROOT_AOD <- estimate_richness(ps_18_month_ITS_ROOT_AOD, measures = c("Shannon"))

# Convert phyloseq sample_data for ROOT to dataframe
LPOST_ITS_opt_1_df_ITS_ROOT_AOD <- as(sample_data(ps_18_month_ITS_ROOT_AOD), "data.frame")

# Add Shannon diversity to the ROOT dataframe
LPOST_ITS_opt_1_df_ITS_ROOT_AOD$Shannon <- diversity_data_ROOT_AOD$Shannon

# Reshape data for Shannon diversity index only
LPOST_ITS_opt_1_df_long_ROOT_AOD <- LPOST_ITS_opt_1_df_ITS_ROOT_AOD %>%
  pivot_longer(cols = "Shannon", 
               names_to = "Diversity_Index", 
               values_to = "Value")

# Create plot with AOD on x-axis and faceting by Treatment (for ROOT only)
LPOST_ITS_opt_1_alpha_ROOT_AOD <- ggplot(LPOST_ITS_opt_1_df_long_ROOT_AOD, aes(x = AOD, y = Value, fill = AOD)) +
  geom_boxplot(outlier.shape = NA, position = position_dodge(width = 0.75), alpha = 0.8) +
  geom_jitter(width = 0.2, alpha = 0.6, color = "black", size = 2) +
  facet_wrap(~ Treatment, scales = "free_y", 
             labeller = labeller(Treatment = c(
               "C" = "Control",
               "D" = "Rain Exclusion",
               "R" = "Ringbarked"
             ))) +  # Map labels for Treatment
  labs(x = NULL, y = "Shannon Diversity Index") +  # Label change
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 28, face = "bold"),
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.ticks.x = element_blank(), # Remove x-axis ticks
    legend.title = element_text(size = 28, face = "bold"),
    legend.text = element_text(size = 24, face = "bold"),
    legend.position = "right",
    strip.background = element_blank(),
    strip.text = element_text(size = 28, face = "bold"),
    panel.grid.minor.x = element_blank(),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_blank(),
    plot.margin = margin(0.5, 0.5, 0.5, 0.5, "cm"),
    plot.background = element_rect(color = "white")
  ) +
  guides(fill = guide_legend(override.aes = list(shape = NA))) +
  scale_fill_manual(
    values = c("N" = "#4C4CFF", "Y" = "#FF4C4C"), # Colorblind-friendly colors
    labels = c("N" = "No AOD", "Y" = "With AOD")
  )

# Print the plot
print(LPOST_ITS_opt_1_alpha_ROOT_AOD)

# Perform Kruskal-Wallis test grouped by Treatment and AOD for ROOT
LPOST_ITS_opt_1_kruskal_results_ROOT_AOD <- LPOST_ITS_opt_1_df_long_ROOT_AOD %>%
  group_by(Treatment) %>%
  summarise(
    test_result = list(kruskal.test(Value ~ AOD, data = cur_data())),
    .groups = "drop"
  )

# Extract and print Kruskal-Wallis p-values for ROOT
LPOST_ITS_opt_1_kruskal_results_ROOT_AOD <- LPOST_ITS_opt_1_kruskal_results_ROOT_AOD %>%
  rowwise() %>%
  mutate(p_value = test_result$p.value) %>%
  select(Treatment, p_value)
print(LPOST_ITS_opt_1_kruskal_results_ROOT_AOD)

# Perform pairwise Wilcoxon rank-sum test grouped by Treatment and AOD for ROOT
LPOST_ITS_opt_1_wilcoxon_results_ROOT_AOD <- LPOST_ITS_opt_1_df_long_ROOT_AOD %>%
  group_by(Treatment) %>%
  pairwise_wilcox_test(Value ~ AOD, p.adjust.method = "bonferroni")

# Add significance annotations
LPOST_ITS_opt_1_annotated_results_ROOT_AOD <- LPOST_ITS_opt_1_wilcoxon_results_ROOT_AOD %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Calculate maximum y-values for placement of annotations for ROOT
LPOST_ITS_opt_1_max_y_ROOT_AOD <- LPOST_ITS_opt_1_df_long_ROOT_AOD %>%
  group_by(Treatment, AOD) %>%
  summarize(max_value = max(Value, na.rm = TRUE)) %>%
  ungroup()

# Ensure that AOD is included in the Wilcoxon test results
LPOST_ITS_opt_1_wilcoxon_results_ROOT_with_AOD <- LPOST_ITS_opt_1_wilcoxon_results_ROOT_AOD %>%
  left_join(LPOST_ITS_opt_1_df_long_ROOT_AOD %>% select(Treatment, AOD) %>% distinct(), by = "Treatment")

# Add significance annotations based on adjusted p-values
LPOST_ITS_opt_1_wilcoxon_results_ROOT_with_AOD <- LPOST_ITS_opt_1_wilcoxon_results_ROOT_with_AOD %>%
  mutate(Significance = case_when(
    p.adj <= 0.001 ~ "***",
    p.adj <= 0.01 ~ "**",
    p.adj <= 0.05 ~ "*",
    TRUE ~ "ns"
  ))

# Now merge the max_value from LPOST_ITS_opt_1_max_y_ROOT into the Wilcoxon test results
LPOST_ITS_opt_1_annotated_results_ROOT_AOD <- LPOST_ITS_opt_1_wilcoxon_results_ROOT_with_AOD %>%
  left_join(LPOST_ITS_opt_1_max_y_ROOT_AOD, by = c("Treatment", "AOD"))

# Add y.position for annotation (e.g., adding 0.1 to max_value for visual placement)
LPOST_ITS_opt_1_annotated_results_ROOT_AOD <- LPOST_ITS_opt_1_annotated_results_ROOT_AOD %>%
  mutate(y.position = max_value + 0.1) %>%
  filter(row_number() %% 2 == 1)  # Keeps only every other row


# Now you can safely add the significance annotations to the plot
LPOST_ITS_opt_1_alpha_ROOT_AOD <- LPOST_ITS_opt_1_alpha_ROOT_AOD +
  stat_pvalue_manual(LPOST_ITS_opt_1_annotated_results_ROOT_AOD,
                     label = "Significance",
                     y.position = "y.position",
                     tip.length = 0.01,
                     size = 10,
                     bracket.size = 2.5,
                     hide.ns = TRUE)

# Print the final plot with annotations for ROOT
print(LPOST_ITS_opt_1_alpha_ROOT_AOD)
```

#Combining alpha diversity graphs
```{r}
#Combining alpha diversity with tissues - annotation labels
#List of plots: 

#Time point 2
#shannon_plot_ps_3_month_16S_leaf
#shannon_plot_ps_3_month_16S_stem
#shannon_plot_ps_3_month_16S_root


#shannon_plot_ps_3_month_ITS_leaf
#shannon_plot_ps_3_month_ITS_stem
#shannon_plot_ps_3_month_ITS_root


#Time point 3
#POST_16S_opt_1_alpha_STEM
#POST_16S_opt_1_alpha_STEM_AOD

#POST_16S_opt_1_alpha_ROOT
#POST_16S_opt_1_alpha_ROOT_AOD


#POST_ITS_opt_1_alpha_STEM
#POST_ITS_opt_1_alpha_STEM_AOD

#POST_ITS_opt_1_alpha_ROOT
#POST_ITS_opt_1_alpha_ROOT_AOD


#Time point 4
#LPOST_16S_opt_1_alpha_STEM
#LPOST_16S_opt_1_alpha_STEM_AOD

#LPOST_16S_opt_1_alpha_Leaf
#LPOST_16S_opt_1_alpha_Leaf_AOD

#LPOST_16S_opt_1_alpha_ROOT
#LPOST_16S_opt_1_alpha_ROOT_AOD


#LPOST_ITS_opt_1_alpha_STEM
#LPOST_ITS_opt_1_alpha_STEM_AOD

#LPOST_ITS_opt_1_alpha_Leaf
#LPOST_ITS_opt_1_alpha_Leaf_AOD

#LPOST_ITS_opt_1_alpha_ROOT
#LPOST_ITS_opt_1_alpha_ROOT_AOD

#--------- Combining stem ----------

# Function to add external annotation to the top-left of a plot
add_annotation <- function(plot, label) {
  ggdraw() +
    draw_plot(plot) +
    draw_plot_label(label, x = 0, y = 1, hjust = -0.5, vjust = 1.5, size = 30, fontface = "bold")
}

# Time Point 2
shannon_plot_ps_3_month_16S_stem_label <- add_annotation(shannon_plot_ps_3_month_16S_stem, "A")
shannon_plot_ps_3_month_ITS_stem_label <- add_annotation(shannon_plot_ps_3_month_ITS_stem, "B")


#Time point 2
shannon_plot_ps_3_month_16S_stem_label <- shannon_plot_ps_3_month_16S_stem_label +
  theme(plot.margin = margin(0, 75, 0, 75)) # Top, Right, Bottom, Left

shannon_plot_ps_3_month_ITS_stem_label <- shannon_plot_ps_3_month_ITS_stem_label +
  theme(plot.margin = margin(0, 75, 0, 75)) # Top, Right, Bottom, Left

timepoint_2 <- ggarrange(
  shannon_plot_ps_3_month_16S_stem_label, shannon_plot_ps_3_month_ITS_stem_label, 
  ncol = 2, nrow = 1
)


# Time Point 3
POST_16S_opt_1_alpha_STEM_label <- add_annotation(POST_16S_opt_1_alpha_STEM, "C")
POST_ITS_opt_1_alpha_STEM_label <- add_annotation(POST_ITS_opt_1_alpha_STEM, "D")
POST_16S_opt_1_alpha_STEM_AOD_label <- add_annotation(POST_16S_opt_1_alpha_STEM_AOD, "E")
POST_ITS_opt_1_alpha_STEM_AOD_label <- add_annotation(POST_ITS_opt_1_alpha_STEM_AOD, "F")

timepoint_3 <- ggarrange(
  ggarrange(POST_16S_opt_1_alpha_STEM_label, POST_ITS_opt_1_alpha_STEM_label, nrow = 1),
  ggarrange(POST_16S_opt_1_alpha_STEM_AOD_label, POST_ITS_opt_1_alpha_STEM_AOD_label, nrow = 1),
  ncol = 1, nrow = 2
)

# Time Point 4
LPOST_16S_opt_1_alpha_STEM_label <- add_annotation(LPOST_16S_opt_1_alpha_STEM, "G")
LPOST_ITS_opt_1_alpha_STEM_label <- add_annotation(LPOST_ITS_opt_1_alpha_STEM, "H")
LPOST_16S_opt_1_alpha_STEM_AOD_label <- add_annotation(LPOST_16S_opt_1_alpha_STEM_AOD, "I")
LPOST_ITS_opt_1_alpha_STEM_AOD_label <- add_annotation(LPOST_ITS_opt_1_alpha_STEM_AOD, "J")

timepoint_4 <- ggarrange(
  ggarrange(LPOST_16S_opt_1_alpha_STEM_label, LPOST_ITS_opt_1_alpha_STEM_label, nrow = 1),
  ggarrange(LPOST_16S_opt_1_alpha_STEM_AOD_label, LPOST_ITS_opt_1_alpha_STEM_AOD_label, nrow = 1),
  ncol = 1, nrow = 2
)

# Headers and Labels
timepoint_2_label <- text_grob("TIME POINT 2", face = "bold", size = 32, just = "center")
timepoint_3_label <- text_grob("TIME POINT 3", face = "bold", size = 32, just = "center")
timepoint_4_label <- text_grob("TIME POINT 4", face = "bold", size = 32, just = "center")

header_labels <- ggarrange(
  text_grob("BACTERIA", face = "bold", size = 36, just = "center"),
  text_grob("FUNGI", face = "bold", size = 36, just = "center"),
  ncol = 2, nrow = 1
)

# Arrange Everything
combined_plot <- ggarrange(
  header_labels,
  timepoint_2_label, timepoint_2,
  timepoint_3_label, timepoint_3,
  timepoint_4_label, timepoint_4,
  ncol = 1, nrow = 7, heights = c(0.15, 0.15, 0.8, 0.15, 1.5, 0.15, 1.5)
)

# Save the plot
ggsave(
  "D:\\PhD_Bioinformatics\\Thesis_Resubmission\\Images\\alpha_diversity_stem_labelled.png",
  combined_plot,
  width = 25,
  height = 35,
  dpi = 600,
  bg = "white"
)

#-------- Combining roots ----------

# Function to add external annotation to the top-left of a plot
add_annotation <- function(plot, label) {
  ggdraw() +
    draw_plot(plot) +
    draw_plot_label(label, x = 0, y = 1, hjust = -0.5, vjust = 1.5, size = 30, fontface = "bold")
}

# Time Point 2
shannon_plot_ps_3_month_16S_root_label <- add_annotation(shannon_plot_ps_3_month_16S_root, "A")
shannon_plot_ps_3_month_ITS_root_label <- add_annotation(shannon_plot_ps_3_month_ITS_root, "B")


#Time point 2
shannon_plot_ps_3_month_16S_root_label <- shannon_plot_ps_3_month_16S_root_label +
  theme(plot.margin = margin(0, 75, 0, 75)) # Top, Right, Bottom, Left

shannon_plot_ps_3_month_ITS_root_label <- shannon_plot_ps_3_month_ITS_root_label +
  theme(plot.margin = margin(0, 75, 0, 75)) # Top, Right, Bottom, Left

timepoint_2 <- ggarrange(
  shannon_plot_ps_3_month_16S_root_label, shannon_plot_ps_3_month_ITS_root_label, 
  ncol = 2, nrow = 1
)


# Time Point 3
POST_16S_opt_1_alpha_ROOT_label <- add_annotation(POST_16S_opt_1_alpha_ROOT, "C")
POST_ITS_opt_1_alpha_ROOT_label <- add_annotation(POST_ITS_opt_1_alpha_ROOT, "D")
POST_16S_opt_1_alpha_ROOT_AOD_label <- add_annotation(POST_16S_opt_1_alpha_ROOT_AOD, "E")
POST_ITS_opt_1_alpha_ROOT_AOD_label <- add_annotation(POST_ITS_opt_1_alpha_ROOT_AOD, "F")

timepoint_3 <- ggarrange(
  ggarrange(POST_16S_opt_1_alpha_ROOT_label, POST_ITS_opt_1_alpha_ROOT_label, nrow = 1),
  ggarrange(POST_16S_opt_1_alpha_ROOT_AOD_label, POST_ITS_opt_1_alpha_ROOT_AOD_label, nrow = 1),
  ncol = 1, nrow = 2
)

# Time Point 4
LPOST_16S_opt_1_alpha_ROOT_label <- add_annotation(LPOST_16S_opt_1_alpha_ROOT, "G")
LPOST_ITS_opt_1_alpha_ROOT_label <- add_annotation(LPOST_ITS_opt_1_alpha_ROOT, "H")
LPOST_16S_opt_1_alpha_ROOT_AOD_label <- add_annotation(LPOST_16S_opt_1_alpha_ROOT_AOD, "I")
LPOST_ITS_opt_1_alpha_ROOT_AOD_label <- add_annotation(LPOST_ITS_opt_1_alpha_ROOT_AOD, "J")

timepoint_4 <- ggarrange(
  ggarrange(LPOST_16S_opt_1_alpha_ROOT_label, LPOST_ITS_opt_1_alpha_ROOT_label, nrow = 1),
  ggarrange(LPOST_16S_opt_1_alpha_ROOT_AOD_label, LPOST_ITS_opt_1_alpha_ROOT_AOD_label, nrow = 1),
  ncol = 1, nrow = 2
)

# Headers and Labels
timepoint_2_label <- text_grob("TIME POINT 2", face = "bold", size = 32, just = "center")
timepoint_3_label <- text_grob("TIME POINT 3", face = "bold", size = 32, just = "center")
timepoint_4_label <- text_grob("TIME POINT 4", face = "bold", size = 32, just = "center")

header_labels <- ggarrange(
  text_grob("BACTERIA", face = "bold", size = 36, just = "center"),
  text_grob("FUNGI", face = "bold", size = 36, just = "center"),
  ncol = 2, nrow = 1
)

# Arrange Everything
combined_plot <- ggarrange(
  header_labels,
  timepoint_2_label, timepoint_2,
  timepoint_3_label, timepoint_3,
  timepoint_4_label, timepoint_4,
  ncol = 1, nrow = 7, heights = c(0.15, 0.15, 0.8, 0.15, 1.5, 0.15, 1.5)
)

# Save the plot
ggsave(
  "D:\\PhD_Bioinformatics\\Thesis_Resubmission\\Images\\alpha_diversity_root_labelled.png",
  combined_plot,
  width = 25,
  height = 35,
  dpi = 600,
  bg = "white"
)

#-------- Combining leaves ----------

# Function to add external annotation to the top-left of a plot
add_annotation <- function(plot, label) {
  ggdraw() +
    draw_plot(plot) +
    draw_plot_label(label, x = 0, y = 1, hjust = -0.5, vjust = 1.5, size = 30, fontface = "bold")
}

# Time Point 2
shannon_plot_ps_3_month_16S_leaf_label <- add_annotation(shannon_plot_ps_3_month_16S_leaf, "A")
shannon_plot_ps_3_month_ITS_leaf_label <- add_annotation(shannon_plot_ps_3_month_ITS_leaf, "B")


#Time point 2
shannon_plot_ps_3_month_16S_leaf_label <- shannon_plot_ps_3_month_16S_leaf_label +
  theme(plot.margin = margin(0, 75, 0, 75)) # Top, Right, Bottom, Left

shannon_plot_ps_3_month_ITS_leaf_label <- shannon_plot_ps_3_month_ITS_leaf_label +
  theme(plot.margin = margin(0, 75, 0, 75)) # Top, Right, Bottom, Left

timepoint_2 <- ggarrange(
  shannon_plot_ps_3_month_16S_leaf_label, shannon_plot_ps_3_month_ITS_leaf_label, 
  ncol = 2, nrow = 1
)


# Time Point 4
LPOST_16S_opt_1_alpha_Leaf_label <- add_annotation(LPOST_16S_opt_1_alpha_Leaf, "C")
LPOST_ITS_opt_1_alpha_Leaf_label <- add_annotation(LPOST_ITS_opt_1_alpha_Leaf, "D")
LPOST_16S_opt_1_alpha_Leaf_AOD_label <- add_annotation(LPOST_16S_opt_1_alpha_Leaf_AOD, "E")
LPOST_ITS_opt_1_alpha_Leaf_AOD_label <- add_annotation(LPOST_ITS_opt_1_alpha_Leaf_AOD, "F")

timepoint_4 <- ggarrange(
  ggarrange(LPOST_16S_opt_1_alpha_Leaf_label, LPOST_ITS_opt_1_alpha_Leaf_label, nrow = 1),
  ggarrange(LPOST_16S_opt_1_alpha_Leaf_AOD_label, LPOST_ITS_opt_1_alpha_Leaf_AOD_label, nrow = 1),
  ncol = 1, nrow = 2
)

# Headers and Labels
timepoint_2_label <- text_grob("TIME POINT 2", face = "bold", size = 32, just = "center")
timepoint_4_label <- text_grob("TIME POINT 4", face = "bold", size = 32, just = "center")

header_labels <- ggarrange(
  text_grob("BACTERIA", face = "bold", size = 36, just = "center"),
  text_grob("FUNGI", face = "bold", size = 36, just = "center"),
  ncol = 2, nrow = 1
)

# Arrange Everything
combined_plot <- ggarrange(
  header_labels,
  timepoint_2_label, timepoint_2,
  timepoint_4_label, timepoint_4,
  ncol = 1, nrow = 7, heights = c(0.15, 0.15, 0.8, 0.15, 1.5)
)

# Save the plot
ggsave(
  "D:\\PhD_Bioinformatics\\Thesis_Resubmission\\Images\\alpha_diversity_leaf_labelled.png",
  combined_plot,
  width = 25,
  height = 25,
  dpi = 600,
  bg = "white"
)
```

#Loading and filtering phyloseq objects for DAA
```{r}
ps_16S <- readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\16S_All\\Tag_Jumping\\ps_AOD_16S_filtered.RDS")

samples_to_remove <- c(
  "P2_PR_T333_B3_R_L", "P2_PR_T631_B6_R_L", "P2_PR_T324_B3_C_L", "P2_PR_T435_B4_R_L",
  "P2_PR_T434_B4_R_L", "P2_PR_T528_B5_C_L", "P2_PR_T135_B1_R_L", "P2_PR_T512_B5_D_L",
  "P2_PR_T427_B4_C_L", "P2_PR_T414_B4_D_L", "P2_PR_T217_B2_D_S", "P2_PR_T522_B5_C_S",
  "P2_PR_T636_B6_R_S", "P3_PR_T111_B1_D_R", "P3_PR_T313_B3_D_R", "P3_PR_T331_B3_R_R",
  "P3_PR_T128_B1_C_R", "P3_PR_T218_B2_D_R", "P3_PR_T315_B3_D_R", "P4_PR_T522_B5_C_L",
  "P2_PR_T124_B1_C_R", "P3_PO_T224_B2_C_S", "P4_LP_T528_B5_C_S", "P4_LP_T312_B3_D_S",
  "P2_BA_T424_B4_C_S", "P4_LP_T513_B5_D_S", "P1_BA_T521_B5_C_R", "P4_LP_T625_B6_C_L",
  "P1_BA_T625_B6_C_R", "P4_LP_T633_B6_R_S", "P1_BA_T114_B1_D_L", "P4_LP_T526_B5_C_S",
  "P4_LP_T517_B5_D_S", "P4_LP_T235_B2_R_S"
)

ps_16S <- microViz::ps_filter(ps_16S, !Sample.ID %in% samples_to_remove)

ps_ITS <- readRDS("F:\\Bioinformatics\\Big_Experiment_Attempt_2\\ITS_All\\Tag_Jumping\\ps_AOD_ITS_filtered_k_removed.RDS")

# Remove negative controls, zymos, and mPNA clamp test
ps_ITS <- microViz::ps_filter(ps_ITS, !grepl("P2_PR_T211_B2_D_L", Sample.ID))

#Filtering out incertae sedis from fungi
# Convert taxonomy table to a dataframe
tax_df <- as.data.frame(tax_table(ps_ITS))

# Find rows where any column contains "Incertae_sedis"
taxa_to_remove <- rownames(tax_df)[apply(tax_df, 1, function(x) any(grepl("Incertae_sedis", x, ignore.case = TRUE)))]

# Remove those taxa from the phyloseq object
ps_ITS <- prune_taxa(!taxa_names(ps_ITS) %in% taxa_to_remove, ps_ITS)

check_tax <- as.data.frame(tax_table(ps_16S))
```

#Renaming Burkholderia-Caballeronia-Paraburkholderia
```{r}
# Extract the taxonomy table
tax_table_df <- as.data.frame(tax_table(ps_16S))

# Rename the ASV
tax_table_df$Genus[tax_table_df$Genus == "Burkholderia-Caballeronia-Paraburkholderia"] <- "BCP"

# Update the taxonomy table in the phyloseq object
tax_table(ps_16S) <- as.matrix(tax_table_df)
```

#DAA - Phylum ----------------
#DAA - 16S - TP3 - Phylum - AOD
```{r}
# Load necessary libraries
library(DESeq2)
library(ggplot2)
library(dplyr)
library(phyloseq)
library(reshape2)

# Filter phyloseq object for POST conditions
POST_16S_opt_1 <- microViz::ps_filter(ps_16S, 
                                       grepl("ROOT|LEAF|STEM", Organ) & 
                                       grepl("\\bPOST\\b", Time))

# Aggregate to phylum level
ps_phylum <- tax_glom(POST_16S_opt_1, taxrank = "Phylum")

# Add a pseudocount of 1
otu_table(ps_phylum) <- otu_table(ps_phylum) + 1

# Create DESeq2 object with the original design formula
diagdds <- phyloseq_to_deseq2(ps_phylum, ~ Organ + Treatment + AOD + Organ:Treatment + Organ:AOD + Organ:Treatment:AOD + Organ:AOD:Treatment)

# Perform DESeq2 analysis
diagdds_res <- DESeq(diagdds, test = "Wald", fitType = "parametric")

# Inspect result names
resultsNames(diagdds_res)

# ---- Step 1: Update the Design for Specific Condition Comparisons ---- #
# Create a composite factor combining Organ, Treatment, and AOD
diagdds$Group <- factor(paste(diagdds$Organ, diagdds$Treatment, diagdds$AOD, sep="_"))

# Update the design to use the new Group variable
design(diagdds) <- ~ Group

# Re-run DESeq2 analysis with the updated design
diagdds <- DESeq(diagdds)

resultsNames(diagdds)

# ---- Step 2: Perform Direct Comparisons ---- #
# Compare specific conditions

res_Root_D <- results(diagdds, contrast=c("Group", "ROOT_D_Y", "ROOT_D_N"))
res_Root_C <- results(diagdds, contrast=c("Group", "ROOT_C_Y", "ROOT_C_N"))
res_Root_R <- results(diagdds, contrast=c("Group", "ROOT_R_Y", "ROOT_R_N"))

res_Stem_D <- results(diagdds, contrast=c("Group", "STEM_D_Y", "STEM_D_N"))
res_Stem_C <- results(diagdds, contrast=c("Group", "STEM_C_Y", "STEM_C_N"))
res_Stem_R <- results(diagdds, contrast=c("Group", "STEM_R_Y", "STEM_R_N"))


# Create a list to hold each result and add labels for each comparison
results_list <- list()

# Add root-related results to the list
results_list$Root_D <- as.data.frame(res_Root_D)
results_list$Root_C <- as.data.frame(res_Root_C)
results_list$Root_R <- as.data.frame(res_Root_R)

# Add stem-related results to the list
results_list$Stem_D <- as.data.frame(res_Stem_D)
results_list$Stem_C <- as.data.frame(res_Stem_C)
results_list$Stem_R <- as.data.frame(res_Stem_R)

# Now combine all the results into one data frame and label each result
combined_results <- bind_rows(results_list, .id = "Comparison")

# Filter based on padj value
filtered_results <- combined_results %>%
  filter(padj <= 0.05)

# Filter based on log2FoldChange
filtered_results <- filtered_results %>%
  filter(log2FoldChange < -1 | log2FoldChange > 1)

#Storing tax table
tax_table_ps <- tax_table(ps_phylum)

# Match Phylum names from `tax_table_ps`
filtered_results$Phylum <- sapply(rownames(filtered_results), function(row_name) {
  if (row_name %in% rownames(tax_table_ps)) {
    tax_table_ps@.Data[row_name, "Phylum"]
  } else {
    NA
  }
})

# Remove rows with NA Phylum
final_results <- filtered_results %>%
  filter(!is.na(Phylum))

# Order Genera by their maximum log2FoldChange
phylum_order <- final_results %>%
  group_by(Phylum) %>%
  summarize(max_log2FoldChange = -max(log2FoldChange, na.rm = TRUE)) %>%
  arrange(desc(max_log2FoldChange))

# Ensure Phylum levels are ordered
final_results$Phylum <- factor(final_results$Phylum, levels = phylum_order$Phylum)

# Step 1: Ensure all Phylum-Comparison pairs are present, even if no data exists for them
all_combinations <- expand.grid(
  Phylum = unique(final_results$Phylum),
  Comparison = unique(final_results$Comparison)
)

# Merge with final_results to ensure every combination exists, even without data
heatmap_data_complete <- merge(all_combinations, final_results, by = c("Phylum", "Comparison"), all.x = TRUE)

# Replace NAs in log2FoldChange with 0 (or choose another value as needed)
heatmap_data_complete$log2FoldChange[is.na(heatmap_data_complete$log2FoldChange)] <- 0

# Step 2: Melt the data for ggplot
heatmap_data_melted <- heatmap_data_complete %>%
  select(Phylum, Comparison, log2FoldChange) %>%
  melt(id.vars = c("Phylum", "Comparison"), variable.name = "Metric", value.name = "Value")

# Step 2.1: Get the top 20 most differentially abundant genera based on log2FoldChange
top_20_phylum <- heatmap_data_complete %>%
  arrange(desc(abs(log2FoldChange))) %>%  # Sort by absolute value of log2FoldChange
  slice_head(n = 20) %>%  # Select the top 20 rows
  pull(Phylum)  # Extract the phylum names

# Step 3: Filter to retain only the top 20 genera in the melted data
heatmap_data_melted_top20 <- heatmap_data_melted %>%
  filter(Phylum %in% top_20_phylum)

# Modify the 'Comparison' column
heatmap_data_melted_top20 <- heatmap_data_melted_top20 %>%
  mutate(Comparison = recode(Comparison, 
                            "Stem_D" = "Stem - Rain Exclusion", 
                            "Stem_C" = "Stem - Control", 
                            "Stem_R" = "Stem - Ringbarked", 
                            "Root_D" = "Root - Rain Exclusion", 
                            "Root_C" = "Root - Control", 
                            "Root_R" = "Root - Ringbarked"))

# Reorder the 'Comparison' factor levels
heatmap_data_melted_top20$Comparison <- factor(heatmap_data_melted_top20$Comparison, 
                                                levels = c("Stem - Control", "Stem - Rain Exclusion", "Stem - Ringbarked", 
                                                           "Root - Control", "Root - Rain Exclusion", "Root - Ringbarked"))

# Plot the heatmap
DAA_Plot_POST_16S <- ggplot(heatmap_data_melted_top20, aes(x = Comparison, y = Phylum, fill = Value)) +
  geom_tile(color = "black", size = 0.7) +  # Add thicker black borders for every cell
  scale_fill_gradient2(
    low = "blue", mid = "grey", high = "red",
    midpoint = 0, 
    name = "log2FoldChange",
    limits = c(-6, 6),  # Set custom limits
    breaks = seq(-6, 6, by = 2)
  ) + 
  labs(
    title = NULL,
    x = NULL,
    y = "Phylum"
  ) +
  theme_minimal(base_size = 14) +  # Increased base font size for consistency
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 30, face = "bold", colour = "black"),  # Larger and bold X axis text
    axis.text.y = element_text(size = 30, face = "bold", colour = "black"),  # Larger and bold Y axis text
    axis.title.x = element_text(size = 30, face = "bold", colour = "black"),  # Bold and larger X axis title (if any)
    axis.title.y = element_text(size = 30, face = "bold", colour = "black"),  # Bold and larger Y axis title
    plot.title = element_text(hjust = 0.5, size = 18, face = "bold"),  # Larger and bold title (if used)
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.title = element_text(size = 30, face = "bold", margin = margin(b = 20)),
    legend.text = element_text(size = 30, face = "bold"),
    legend.key.height = unit(2, "cm"),  # Increase the height of the legend bar
    legend.key.width = unit(0.5, "cm")  # Increase the width of the legend bar
  )

# Print the plot
print(DAA_Plot_POST_16S)
```

#DAA - 16S - TP4 - Phylum - AOD
```{r}
# Load necessary libraries
library(DESeq2)
library(ggplot2)
library(dplyr)
library(phyloseq)
library(reshape2)
library(cowplot)

# Filter phyloseq object for LPOST conditions
LPOST_16S_opt_1 <- microViz::ps_filter(ps_16S, 
                                       grepl("ROOT|LEAF|STEM", Organ) & 
                                       grepl("\\bLPOST\\b", Time))

# Aggregate to phylum level
ps_phylum <- tax_glom(LPOST_16S_opt_1, taxrank = "Phylum")

# Add a pseudocount of 1
otu_table(ps_phylum) <- otu_table(ps_phylum) + 1

# Create DESeq2 object with the original design formula
diagdds <- phyloseq_to_deseq2(ps_phylum, ~ Organ + Treatment + AOD + Organ:Treatment + Organ:AOD + Organ:Treatment:AOD + Organ:AOD:Treatment)

# Perform DESeq2 analysis
diagdds_res <- DESeq(diagdds, test = "Wald", fitType = "parametric")

# Inspect result names
resultsNames(diagdds_res)

# ---- Step 1: Update the Design for Specific Condition Comparisons ---- #
# Create a composite factor combining Organ, Treatment, and AOD
diagdds$Group <- factor(paste(diagdds$Organ, diagdds$Treatment, diagdds$AOD, sep="_"))

# Update the design to use the new Group variable
design(diagdds) <- ~ Group

# Re-run DESeq2 analysis with the updated design
diagdds <- DESeq(diagdds)

resultsNames(diagdds)

# ---- Step 2: Perform Direct Comparisons ---- #
# Compare specific conditions

res_Root_D <- results(diagdds, contrast=c("Group", "ROOT_D_Y", "ROOT_D_N"))
res_Root_C <- results(diagdds, contrast=c("Group", "ROOT_C_Y", "ROOT_C_N"))
res_Root_R <- results(diagdds, contrast=c("Group", "ROOT_R_Y", "ROOT_R_N"))

res_Stem_D <- results(diagdds, contrast=c("Group", "STEM_D_Y", "STEM_D_N"))
res_Stem_C <- results(diagdds, contrast=c("Group", "STEM_C_Y", "STEM_C_N"))
res_Stem_R <- results(diagdds, contrast=c("Group", "STEM_R_Y", "STEM_R_N"))

res_Leaf_D <- results(diagdds, contrast=c("Group", "LEAF_D_Y", "LEAF_D_N"))
res_Leaf_C <- results(diagdds, contrast=c("Group", "LEAF_C_Y", "LEAF_C_N"))
res_Leaf_R <- results(diagdds, contrast=c("Group", "LEAF_R_Y", "LEAF_R_N"))


# Create a list to hold each result and add labels for each comparison
results_list <- list()

# Add root-related results to the list
results_list$Root_D <- as.data.frame(res_Root_D)
results_list$Root_C <- as.data.frame(res_Root_C)
results_list$Root_R <- as.data.frame(res_Root_R)

# Add stem-related results to the list
results_list$Stem_D <- as.data.frame(res_Stem_D)
results_list$Stem_C <- as.data.frame(res_Stem_C)
results_list$Stem_R <- as.data.frame(res_Stem_R)

# Add leaf-related results to the list
results_list$Leaf_D <- as.data.frame(res_Leaf_D)
results_list$Leaf_C <- as.data.frame(res_Leaf_C)
results_list$Leaf_R <- as.data.frame(res_Leaf_R)

# Now combine all the results into one data frame and label each result
combined_results <- bind_rows(results_list, .id = "Comparison")

# Filter based on padj value
filtered_results <- combined_results %>%
  filter(padj <= 0.05)

# Filter based on log2FoldChange
filtered_results <- filtered_results %>%
  filter(log2FoldChange < -1 | log2FoldChange > 1)

#Storing tax table
tax_table_ps <- tax_table(ps_phylum)

# Match Phylum names from `tax_table_ps`
filtered_results$Phylum <- sapply(rownames(filtered_results), function(row_name) {
  if (row_name %in% rownames(tax_table_ps)) {
    tax_table_ps@.Data[row_name, "Phylum"]
  } else {
    NA
  }
})

# Remove rows with NA Phylum
final_results <- filtered_results %>%
  filter(!is.na(Phylum))

# Order Genera by their maximum log2FoldChange
phylum_order <- final_results %>%
  group_by(Phylum) %>%
  summarize(max_log2FoldChange = -max(log2FoldChange, na.rm = TRUE)) %>%
  arrange(desc(max_log2FoldChange))

# Ensure Phylum levels are ordered
final_results$Phylum <- factor(final_results$Phylum, levels = phylum_order$Phylum)

# Step 1: Ensure all Phylum-Comparison pairs are present, even if no data exists for them
all_combinations <- expand.grid(
  Phylum = unique(final_results$Phylum),
  Comparison = unique(final_results$Comparison)
)

# Merge with final_results to ensure every combination exists, even without data
heatmap_data_complete <- merge(all_combinations, final_results, by = c("Phylum", "Comparison"), all.x = TRUE)

# Replace NAs in log2FoldChange with 0 (or choose another value as needed)
heatmap_data_complete$log2FoldChange[is.na(heatmap_data_complete$log2FoldChange)] <- 0

# Step 2: Melt the data for ggplot
heatmap_data_melted <- heatmap_data_complete %>%
  select(Phylum, Comparison, log2FoldChange) %>%
  melt(id.vars = c("Phylum", "Comparison"), variable.name = "Metric", value.name = "Value")

# Step 2.1: Get the top 20 most differentially abundant genera based on log2FoldChange
top_20_phylum <- heatmap_data_complete %>%
  arrange(desc(abs(log2FoldChange))) %>%  # Sort by absolute value of log2FoldChange
  slice_head(n = 20) %>%  # Select the top 20 rows
  pull(Phylum)  # Extract the phylum names

# Step 3: Filter to retain only the top 20 genera in the melted data
heatmap_data_melted_top20 <- heatmap_data_melted %>%
  filter(Phylum %in% top_20_phylum)

heatmap_data_melted_top20 <- heatmap_data_melted_top20 %>%
  mutate(Comparison = recode(Comparison, 
                            "Stem_D" = "Stem - Rain Exclusion", 
                            "Stem_C" = "Stem - Control", 
                            "Stem_R" = "Stem - Ringbarked", 
                            "Root_D" = "Root - Rain Exclusion", 
                            "Root_C" = "Root - Control", 
                            "Root_R" = "Root - Ringbarked",
                            "Leaf_D" = "Leaf - Rain Exclusion", 
                            "Leaf_C" = "Leaf - Control", 
                            "Leaf_R" = "Leaf - Ringbarked"
                            ))

# Reorder the 'Comparison' factor levels
heatmap_data_melted_top20$Comparison <- factor(heatmap_data_melted_top20$Comparison, 
                                                levels = c("Leaf - Control", "Leaf - Rain Exclusion", "Leaf - Ringbarked", "Stem - Control", "Stem - Rain Exclusion", "Stem - Ringbarked", "Root - Control", "Root - Rain Exclusion", "Root - Ringbarked"))

# Plot the heatmap
DAA_Plot_LPOST_16S <- ggplot(heatmap_data_melted_top20, aes(x = Comparison, y = Phylum, fill = Value)) +
  geom_tile(color = "black", size = 0.7) +  # Add thicker black borders for every cell
  scale_fill_gradient2(
    low = "blue", mid = "grey", high = "red",
    midpoint = 0, 
    name = "log2FoldChange",
    limits = c(-6, 6),  # Set custom limits
    breaks = seq(-6, 6, by = 2)
  ) + 
  labs(
    title = NULL,
    x = NULL,
    y = "Phylum"
  ) +
  theme_minimal(base_size = 14) +  # Increased base font size for consistency
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 30, face = "bold", colour = "black"),  # Larger and bold X axis text
    axis.text.y = element_text(size = 30, face = "bold", colour = "black"),  # Larger and bold Y axis text
    axis.title.x = element_text(size = 30, face = "bold", colour = "black"),  # Bold and larger X axis title (if any)
    axis.title.y = element_text(size = 30, face = "bold", colour = "black"),  # Bold and larger Y axis title
    plot.title = element_text(hjust = 0.5, size = 18, face = "bold", colour = "black"),  # Larger and bold title (if used)
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.title = element_text(size = 30, face = "bold", margin = margin(b = 20)),
    legend.text = element_text(size = 30, face = "bold"),
    legend.key.height = unit(2, "cm"),  # Increase the height of the legend bar
    legend.key.width = unit(0.5, "cm")  # Increase the width of the legend bar
  )

# Print the plot
print(DAA_Plot_LPOST_16S)
```

#DAA - ITS - TP3 - Class - AOD
```{r}
# Load necessary libraries
library(DESeq2)
library(ggplot2)
library(dplyr)
library(phyloseq)
library(reshape2)



# Filter phyloseq object for LPOST conditions
LPOST_ITS_opt_1 <- microViz::ps_filter(ps_ITS, 
                                       grepl("ROOT|LEAF|STEM", Organ) & 
                                       grepl("\\bPOST\\b", Time))

# Aggregate to Class level
ps_Class <- tax_glom(LPOST_ITS_opt_1, taxrank = "Class")

# Add a pseudocount of 1
otu_table(ps_Class) <- otu_table(ps_Class) + 1

# Create DESeq2 object with the original design formula
diagdds <- phyloseq_to_deseq2(ps_Class, ~ Organ + Treatment + AOD + Organ:Treatment + Organ:AOD + Organ:Treatment:AOD + Organ:AOD:Treatment)

# Perform DESeq2 analysis
diagdds_res <- DESeq(diagdds, test = "Wald", fitType = "parametric")

# Inspect result names
resultsNames(diagdds_res)

# ---- Step 1: Update the Design for Specific Condition Comparisons ---- #
# Create a composite factor combining Organ, Treatment, and AOD
diagdds$Group <- factor(paste(diagdds$Organ, diagdds$Treatment, diagdds$AOD, sep="_"))

# Update the design to use the new Group variable
design(diagdds) <- ~ Group

# Re-run DESeq2 analysis with the updated design
diagdds <- DESeq(diagdds)

resultsNames(diagdds)

# ---- Step 2: Perform Direct Comparisons ---- #
# Compare specific conditions

res_Root_D <- results(diagdds, contrast=c("Group", "ROOT_D_Y", "ROOT_D_N"))
res_Root_C <- results(diagdds, contrast=c("Group", "ROOT_C_Y", "ROOT_C_N"))
res_Root_R <- results(diagdds, contrast=c("Group", "ROOT_R_Y", "ROOT_R_N"))

res_Stem_D <- results(diagdds, contrast=c("Group", "STEM_D_Y", "STEM_D_N"))
res_Stem_C <- results(diagdds, contrast=c("Group", "STEM_C_Y", "STEM_C_N"))
res_Stem_R <- results(diagdds, contrast=c("Group", "STEM_R_Y", "STEM_R_N"))

#res_Leaf_D <- results(diagdds, contrast=c("Group", "LEAF_D_Y", "LEAF_D_N"))
#res_Leaf_C <- results(diagdds, contrast=c("Group", "LEAF_C_Y", "LEAF_C_N"))
#res_Leaf_R <- results(diagdds, contrast=c("Group", "LEAF_R_Y", "LEAF_R_N"))


# Create a list to hold each result and add labels for each comparison
results_list <- list()

# Add root-related results to the list
results_list$Root_D <- as.data.frame(res_Root_D)
results_list$Root_C <- as.data.frame(res_Root_C)
results_list$Root_R <- as.data.frame(res_Root_R)

# Add stem-related results to the list
results_list$Stem_D <- as.data.frame(res_Stem_D)
results_list$Stem_C <- as.data.frame(res_Stem_C)
results_list$Stem_R <- as.data.frame(res_Stem_R)

# Add leaf-related results to the list
#results_list$Leaf_D <- as.data.frame(res_Leaf_D)
#results_list$Leaf_C <- as.data.frame(res_Leaf_C)
#results_list$Leaf_R <- as.data.frame(res_Leaf_R)

# Now combine all the results into one data frame and label each result
combined_results <- bind_rows(results_list, .id = "Comparison")

# Filter based on padj value
filtered_results <- combined_results %>%
  filter(padj <= 0.05)

# Filter based on log2FoldChange
filtered_results <- filtered_results %>%
  filter(log2FoldChange < -1 | log2FoldChange > 1)

#Storing tax table
tax_table_ps <- tax_table(ps_Class)

# Match Class names from `tax_table_ps`
filtered_results$Class <- sapply(rownames(filtered_results), function(row_name) {
  if (row_name %in% rownames(tax_table_ps)) {
    tax_table_ps@.Data[row_name, "Class"]
  } else {
    NA
  }
})

# Remove rows with NA Class
final_results <- filtered_results %>%
  filter(!is.na(Class))

# Order Genera by their maximum log2FoldChange
Class_order <- final_results %>%
  group_by(Class) %>%
  summarize(max_log2FoldChange = -max(log2FoldChange, na.rm = TRUE)) %>%
  arrange(desc(max_log2FoldChange))

# Ensure Class levels are ordered
final_results$Class <- factor(final_results$Class, levels = Class_order$Class)

# Step 1: Ensure all Class-Comparison pairs are present, even if no data exists for them
all_combinations <- expand.grid(
  Class = unique(final_results$Class),
  Comparison = unique(final_results$Comparison)
)

# Merge with final_results to ensure every combination exists, even without data
heatmap_data_complete <- merge(all_combinations, final_results, by = c("Class", "Comparison"), all.x = TRUE)

# Replace NAs in log2FoldChange with 0 (or choose another value as needed)
heatmap_data_complete$log2FoldChange[is.na(heatmap_data_complete$log2FoldChange)] <- 0

# Step 2: Melt the data for ggplot
heatmap_data_melted <- heatmap_data_complete %>%
  select(Class, Comparison, log2FoldChange) %>%
  melt(id.vars = c("Class", "Comparison"), variable.name = "Metric", value.name = "Value")

# Step 2.1: Get the top 20 most differentially abundant genera based on log2FoldChange
top_20_Class <- heatmap_data_complete %>%
  arrange(desc(abs(log2FoldChange))) %>%  # Sort by absolute value of log2FoldChange
  slice_head(n = 20) %>%  # Select the top 20 rows
  pull(Class)  # Extract the Class names

# Step 3: Filter to retain only the top 20 genera in the melted data
heatmap_data_melted_top20 <- heatmap_data_melted %>%
  filter(Class %in% top_20_Class)

heatmap_data_melted_top20 <- heatmap_data_melted_top20 %>%
  mutate(Comparison = recode(Comparison, 
                            "Stem_D" = "Stem - Rain Exclusion", 
                            "Stem_C" = "Stem - Control", 
                            "Stem_R" = "Stem - Ringbarked", 
                            "Root_D" = "Root - Rain Exclusion", 
                            "Root_C" = "Root - Control", 
                            "Root_R" = "Root - Ringbarked"
#                            "Leaf_D" = "Leaf - Rain Exclusion", 
#                            "Leaf_C" = "Leaf - Control", 
#                            "Leaf_R" = "Leaf - Ringbarked"
                            ))

# Reorder the 'Comparison' factor levels
heatmap_data_melted_top20$Comparison <- factor(heatmap_data_melted_top20$Comparison, 
                                                levels = c("Stem - Control", "Stem - Rain Exclusion", "Stem - Ringbarked", "Root - Control", "Root - Rain Exclusion", "Root - Ringbarked"))

# Plot the heatmap
DAA_Plot_POST_ITS <- ggplot(heatmap_data_melted_top20, aes(x = Comparison, y = Class, fill = Value)) +
  geom_tile(color = "black", size = 0.7) +  # Add thicker black borders for every cell
  scale_fill_gradient2(
    low = "blue", mid = "grey", high = "red",
    midpoint = 0, 
    name = "log2FoldChange",
    limits = c(-9, 9),  # Set custom limits
    breaks = seq(-9, 9, by = 3)
  ) + 
  labs(
    title = NULL,
    x = NULL,
    y = "Class"
  ) +
  theme_minimal(base_size = 14) +  # Increased base font size for consistency
  theme_minimal(base_size = 14) +  # Increased base font size for consistency
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 30, face = "bold", colour = "black"),  # Larger and bold X axis text
    axis.text.y = element_text(size = 30, face = "bold", colour = "black"),  # Larger and bold Y axis text
    axis.title.x = element_text(size = 30, face = "bold", colour = "black"),  # Bold and larger X axis title (if any)
    axis.title.y = element_text(size = 30, face = "bold", colour = "black"),  # Bold and larger Y axis title
    plot.title = element_text(hjust = 0.5, size = 18, face = "bold"),  # Larger and bold title (if used)
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.title = element_text(size = 20, face = "bold", margin = margin(b = 20)),
    legend.text = element_text(size = 20, face = "bold"),
    legend.key.height = unit(2, "cm"),  # Increase the height of the legend bar
    legend.key.width = unit(0.5, "cm")  # Increase the width of the legend bar
  )

# Print the plot
print(DAA_Plot_POST_ITS)
```

#DAA - ITS - TP4 - Class - AOD
```{r}
# Load necessary libraries
library(DESeq2)
library(ggplot2)
library(dplyr)
library(phyloseq)
library(reshape2)

# Filter phyloseq object for LPOST conditions
LPOST_ITS_opt_1 <- microViz::ps_filter(ps_ITS, 
                                       grepl("ROOT|LEAF|STEM", Organ) & 
                                       grepl("\\bLPOST\\b", Time))

# Aggregate to Class level
ps_Class <- tax_glom(LPOST_ITS_opt_1, taxrank = "Class")

# Add a pseudocount of 1
otu_table(ps_Class) <- otu_table(ps_Class) + 1

# Create DESeq2 object with the original design formula
diagdds <- phyloseq_to_deseq2(ps_Class, ~ Organ + Treatment + AOD + Organ:Treatment + Organ:AOD + Organ:Treatment:AOD + Organ:AOD:Treatment)

# Perform DESeq2 analysis
diagdds_res <- DESeq(diagdds, test = "Wald", fitType = "parametric")

# Inspect result names
resultsNames(diagdds_res)

# ---- Step 1: Update the Design for Specific Condition Comparisons ---- #
# Create a composite factor combining Organ, Treatment, and AOD
diagdds$Group <- factor(paste(diagdds$Organ, diagdds$Treatment, diagdds$AOD, sep="_"))

# Update the design to use the new Group variable
design(diagdds) <- ~ Group

# Re-run DESeq2 analysis with the updated design
diagdds <- DESeq(diagdds)

resultsNames(diagdds)

# ---- Step 2: Perform Direct Comparisons ---- #
# Compare specific conditions

res_Root_D <- results(diagdds, contrast=c("Group", "ROOT_D_Y", "ROOT_D_N"))
res_Root_C <- results(diagdds, contrast=c("Group", "ROOT_C_Y", "ROOT_C_N"))
res_Root_R <- results(diagdds, contrast=c("Group", "ROOT_R_Y", "ROOT_R_N"))

res_Stem_D <- results(diagdds, contrast=c("Group", "STEM_D_Y", "STEM_D_N"))
res_Stem_C <- results(diagdds, contrast=c("Group", "STEM_C_Y", "STEM_C_N"))
res_Stem_R <- results(diagdds, contrast=c("Group", "STEM_R_Y", "STEM_R_N"))

res_Leaf_D <- results(diagdds, contrast=c("Group", "LEAF_D_Y", "LEAF_D_N"))
res_Leaf_C <- results(diagdds, contrast=c("Group", "LEAF_C_Y", "LEAF_C_N"))
res_Leaf_R <- results(diagdds, contrast=c("Group", "LEAF_R_Y", "LEAF_R_N"))


# Create a list to hold each result and add labels for each comparison
results_list <- list()

# Add root-related results to the list
results_list$Root_D <- as.data.frame(res_Root_D)
results_list$Root_C <- as.data.frame(res_Root_C)
results_list$Root_R <- as.data.frame(res_Root_R)

# Add stem-related results to the list
results_list$Stem_D <- as.data.frame(res_Stem_D)
results_list$Stem_C <- as.data.frame(res_Stem_C)
results_list$Stem_R <- as.data.frame(res_Stem_R)

# Add leaf-related results to the list
results_list$Leaf_D <- as.data.frame(res_Leaf_D)
results_list$Leaf_C <- as.data.frame(res_Leaf_C)
results_list$Leaf_R <- as.data.frame(res_Leaf_R)

# Now combine all the results into one data frame and label each result
combined_results <- bind_rows(results_list, .id = "Comparison")

# Filter based on padj value
filtered_results <- combined_results %>%
  filter(padj <= 0.05)

# Filter based on log2FoldChange
filtered_results <- filtered_results %>%
  filter(log2FoldChange < -1 | log2FoldChange > 1)

#Storing tax table
tax_table_ps <- tax_table(ps_Class)

# Match Class names from `tax_table_ps`
filtered_results$Class <- sapply(rownames(filtered_results), function(row_name) {
  if (row_name %in% rownames(tax_table_ps)) {
    tax_table_ps@.Data[row_name, "Class"]
  } else {
    NA
  }
})

# Remove rows with NA Class
final_results <- filtered_results %>%
  filter(!is.na(Class))

# Order Genera by their maximum log2FoldChange
Class_order <- final_results %>%
  group_by(Class) %>%
  summarize(max_log2FoldChange = -max(log2FoldChange, na.rm = TRUE)) %>%
  arrange(desc(max_log2FoldChange))

# Ensure Class levels are ordered
final_results$Class <- factor(final_results$Class, levels = Class_order$Class)

# Step 1: Ensure all Class-Comparison pairs are present, even if no data exists for them
all_combinations <- expand.grid(
  Class = unique(final_results$Class),
  Comparison = unique(final_results$Comparison)
)

# Merge with final_results to ensure every combination exists, even without data
heatmap_data_complete <- merge(all_combinations, final_results, by = c("Class", "Comparison"), all.x = TRUE)

# Replace NAs in log2FoldChange with 0 (or choose another value as needed)
heatmap_data_complete$log2FoldChange[is.na(heatmap_data_complete$log2FoldChange)] <- 0

# Step 2: Melt the data for ggplot
heatmap_data_melted <- heatmap_data_complete %>%
  select(Class, Comparison, log2FoldChange) %>%
  melt(id.vars = c("Class", "Comparison"), variable.name = "Metric", value.name = "Value")

# Step 2.1: Get the top 20 most differentially abundant genera based on log2FoldChange
top_20_Class <- heatmap_data_complete %>%
  arrange(desc(abs(log2FoldChange))) %>%  # Sort by absolute value of log2FoldChange
  slice_head(n = 20) %>%  # Select the top 20 rows
  pull(Class)  # Extract the Class names

# Step 3: Filter to retain only the top 20 genera in the melted data
heatmap_data_melted_top20 <- heatmap_data_melted %>%
  filter(Class %in% top_20_Class)

heatmap_data_melted_top20 <- heatmap_data_melted_top20 %>%
  mutate(Comparison = recode(Comparison, 
                            "Stem_D" = "Stem - Rain Exclusion", 
                            "Stem_C" = "Stem - Control", 
                            "Stem_R" = "Stem - Ringbarked", 
                            "Root_D" = "Root - Rain Exclusion", 
                            "Root_C" = "Root - Control", 
                            "Root_R" = "Root - Ringbarked",
                            "Leaf_D" = "Leaf - Rain Exclusion", 
                            "Leaf_C" = "Leaf - Control", 
                            "Leaf_R" = "Leaf - Ringbarked"
                            ))

# Reorder the 'Comparison' factor levels
heatmap_data_melted_top20$Comparison <- factor(heatmap_data_melted_top20$Comparison, 
                                                levels = c("Leaf - Control", "Leaf - Rain Exclusion", "Leaf - Ringbarked", "Stem - Control", "Stem - Rain Exclusion", "Stem - Ringbarked", "Root - Control", "Root - Rain Exclusion", "Root - Ringbarked"))

# Plot the heatmap
DAA_Plot_LPOST_ITS <- ggplot(heatmap_data_melted_top20, aes(x = Comparison, y = Class, fill = Value)) +
  geom_tile(color = "black", size = 0.7) +  # Add thicker black borders for every cell
  scale_fill_gradient2(
    low = "blue", mid = "grey", high = "red",
    midpoint = 0, 
    name = "log2FoldChange",
    limits = c(-9, 9),  # Set custom limits
    breaks = seq(-9, 9, by = 3)
  ) + 
  labs(
    title = NULL,
    x = NULL,
    y = "Class"
  ) +
  theme_minimal(base_size = 14) +  # Increased base font size for consistency
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 30, face = "bold", colour = "black"),  # Larger and bold X axis text
    axis.text.y = element_text(size = 30, face = "bold", colour = "black"),  # Larger and bold Y axis text
    axis.title.x = element_text(size = 30, face = "bold", colour = "black"),  # Bold and larger X axis title (if any)
    axis.title.y = element_text(size = 30, face = "bold", colour = "black"),  # Bold and larger Y axis title
    plot.title = element_text(hjust = 0.5, size = 18, face = "bold"),  # Larger and bold title (if used)
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.title = element_text(size = 20, face = "bold", margin = margin(b = 20)),
    legend.text = element_text(size = 20, face = "bold"),
    legend.key.height = unit(2, "cm"),  # Increase the height of the legend bar
    legend.key.width = unit(0.5, "cm")  # Increase the width of the legend bar
  )

# Print the plot
print(DAA_Plot_LPOST_ITS)
```

#DAA - Genus ----------------
#DAA - 16S - TP3 - Genus - AOD
```{r}
# Load necessary libraries
library(DESeq2)
library(ggplot2)
library(dplyr)
library(phyloseq)
library(reshape2)


# Filter phyloseq object for POST conditions
POST_16S_opt_1 <- microViz::ps_filter(ps_16S, 
                                       grepl("ROOT|LEAF|STEM", Organ) & 
                                       grepl("\\bPOST\\b", Time))

# Aggregate to genus level
ps_genus <- tax_glom(POST_16S_opt_1, taxrank = "Genus")

# Add a pseudocount of 1
otu_table(ps_genus) <- otu_table(ps_genus) + 1

# Create DESeq2 object with the original design formula
diagdds <- phyloseq_to_deseq2(ps_genus, ~ Organ + Treatment + AOD + Organ:Treatment + Organ:AOD + Organ:Treatment:AOD + Organ:AOD:Treatment)

# Perform DESeq2 analysis
diagdds_res <- DESeq(diagdds, test = "Wald", fitType = "parametric")

# Inspect result names
resultsNames(diagdds_res)

# ---- Step 1: Update the Design for Specific Condition Comparisons ---- #
# Create a composite factor combining Organ, Treatment, and AOD
diagdds$Group <- factor(paste(diagdds$Organ, diagdds$Treatment, diagdds$AOD, sep="_"))

# Update the design to use the new Group variable
design(diagdds) <- ~ Group

# Re-run DESeq2 analysis with the updated design
diagdds <- DESeq(diagdds)

resultsNames(diagdds)

# ---- Step 2: Perform Direct Comparisons ---- #
# Compare specific conditions

res_Root_D <- results(diagdds, contrast=c("Group", "ROOT_D_Y", "ROOT_D_N"))
res_Root_C <- results(diagdds, contrast=c("Group", "ROOT_C_Y", "ROOT_C_N"))
res_Root_R <- results(diagdds, contrast=c("Group", "ROOT_R_Y", "ROOT_R_N"))

res_Stem_D <- results(diagdds, contrast=c("Group", "STEM_D_Y", "STEM_D_N"))
res_Stem_C <- results(diagdds, contrast=c("Group", "STEM_C_Y", "STEM_C_N"))
res_Stem_R <- results(diagdds, contrast=c("Group", "STEM_R_Y", "STEM_R_N"))


# Create a list to hold each result and add labels for each comparison
results_list <- list()

# Add root-related results to the list
results_list$Root_D <- as.data.frame(res_Root_D)
results_list$Root_C <- as.data.frame(res_Root_C)
results_list$Root_R <- as.data.frame(res_Root_R)

# Add stem-related results to the list
results_list$Stem_D <- as.data.frame(res_Stem_D)
results_list$Stem_C <- as.data.frame(res_Stem_C)
results_list$Stem_R <- as.data.frame(res_Stem_R)

# Now combine all the results into one data frame and label each result
combined_results <- bind_rows(results_list, .id = "Comparison")

# Filter based on padj value
filtered_results <- combined_results %>%
  filter(padj <= 0.05)

# Filter based on log2FoldChange
filtered_results <- filtered_results %>%
  filter(log2FoldChange < -1 | log2FoldChange > 1)

#Storing tax table
tax_table_ps <- tax_table(ps_genus)

# Match Genus names from `tax_table_ps`
filtered_results$Genus <- sapply(rownames(filtered_results), function(row_name) {
  if (row_name %in% rownames(tax_table_ps)) {
    tax_table_ps@.Data[row_name, "Genus"]
  } else {
    NA
  }
})

# Remove rows with NA Genus
final_results <- filtered_results %>%
  filter(!is.na(Genus))

# Order Genera by their maximum log2FoldChange
genus_order <- final_results %>%
  group_by(Genus) %>%
  summarize(max_log2FoldChange = -max(log2FoldChange, na.rm = TRUE)) %>%
  arrange(desc(max_log2FoldChange))

# Ensure Genus levels are ordered
final_results$Genus <- factor(final_results$Genus, levels = genus_order$Genus)

# Step 1: Ensure all Genus-Comparison pairs are present, even if no data exists for them
all_combinations <- expand.grid(
  Genus = unique(final_results$Genus),
  Comparison = unique(final_results$Comparison)
)

# Merge with final_results to ensure every combination exists, even without data
heatmap_data_complete <- merge(all_combinations, final_results, by = c("Genus", "Comparison"), all.x = TRUE)

# Replace NAs in log2FoldChange with 0 (or choose another value as needed)
heatmap_data_complete$log2FoldChange[is.na(heatmap_data_complete$log2FoldChange)] <- 0

# Step 2: Melt the data for ggplot
heatmap_data_melted <- heatmap_data_complete %>%
  select(Genus, Comparison, log2FoldChange) %>%
  melt(id.vars = c("Genus", "Comparison"), variable.name = "Metric", value.name = "Value")

# Step 2.1: Get the top 20 most differentially abundant genera based on log2FoldChange
top_20_genus <- heatmap_data_complete %>%
  arrange(desc(abs(log2FoldChange))) %>%  # Sort by absolute value of log2FoldChange
  slice_head(n = 500) %>%  # Select the top 20 rows
  pull(Genus)  # Extract the genus names

# Step 3: Filter to retain only the top 20 genera in the melted data
heatmap_data_melted_top20 <- heatmap_data_melted %>%
  filter(Genus %in% top_20_genus)

# Modify the 'Comparison' column
heatmap_data_melted_top20 <- heatmap_data_melted_top20 %>%
  mutate(Comparison = recode(Comparison, 
                            "Stem_D" = "Stem - Rain Exclusion", 
                            "Stem_C" = "Stem - Control", 
                            "Stem_R" = "Stem - Ringbarked", 
                            "Root_D" = "Root - Rain Exclusion", 
                            "Root_C" = "Root - Control", 
                            "Root_R" = "Root - Ringbarked"))

# Reorder the 'Comparison' factor levels
heatmap_data_melted_top20$Comparison <- factor(heatmap_data_melted_top20$Comparison, 
                                                levels = c("Stem - Control", "Stem - Rain Exclusion", "Stem - Ringbarked", 
                                                           "Root - Control", "Root - Rain Exclusion", "Root - Ringbarked"))

# Plot the heatmap
DAA_Plot_POST_16S_genus <- ggplot(heatmap_data_melted_top20, aes(x = Comparison, y = Genus, fill = Value)) +
  geom_tile(color = "black", size = 0.7) +  # Add thicker black borders for every cell
  scale_fill_gradient2(
    low = "blue", mid = "grey", high = "red",
    midpoint = 0, 
    name = "log2FoldChange",
    limits = c(-8, 8),  # Set custom limits
    breaks = seq(-8, 8, by = 2)
  ) + 
  labs(
    title = NULL,
    x = NULL,
    y = "Genus"
  ) +
 theme_minimal(base_size = 14) +  # Increased base font size for consistency
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 30, face = "bold", colour = "black"),  # Larger and bold X axis text
    axis.text.y = element_text(size = 30, face = "bold", colour = "black"),  # Larger and bold Y axis text
    axis.title.x = element_text(size = 30, face = "bold", colour = "black"),  # Bold and larger X axis title (if any)
    axis.title.y = element_text(size = 30, face = "bold", colour = "black"),  # Bold and larger Y axis title
    plot.title = element_text(hjust = 0.5, size = 18, face = "bold"),  # Larger and bold title (if used)
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.title = element_text(size = 30, face = "bold", margin = margin(b = 20)),
    legend.text = element_text(size = 30, face = "bold"),
    legend.key.height = unit(2, "cm"),  # Increase the height of the legend bar
    legend.key.width = unit(0.5, "cm")  # Increase the width of the legend bar
  )

# Print the plot
print(DAA_Plot_POST_16S_genus)
```

#DAA - 16S - TP4 - AOD
```{r}
# Load necessary libraries
library(DESeq2)
library(ggplot2)
library(dplyr)
library(phyloseq)
library(reshape2)

# Filter phyloseq object for LPOST conditions
LPOST_16S_opt_1 <- microViz::ps_filter(ps_16S, 
                                       grepl("ROOT|LEAF|STEM", Organ) & 
                                       grepl("\\bLPOST\\b", Time))

# Aggregate to genus level
ps_genus <- tax_glom(LPOST_16S_opt_1, taxrank = "Genus")

# Add a pseudocount of 1
otu_table(ps_genus) <- otu_table(ps_genus) + 1

# Create DESeq2 object with the original design formula
diagdds <- phyloseq_to_deseq2(ps_genus, ~ Organ + Treatment + AOD + Organ:Treatment + Organ:AOD + Organ:Treatment:AOD + Organ:AOD:Treatment)

# Perform DESeq2 analysis
diagdds_res <- DESeq(diagdds, test = "Wald", fitType = "parametric")

# Inspect result names
resultsNames(diagdds_res)

# ---- Step 1: Update the Design for Specific Condition Comparisons ---- #
# Create a composite factor combining Organ, Treatment, and AOD
diagdds$Group <- factor(paste(diagdds$Organ, diagdds$Treatment, diagdds$AOD, sep="_"))

# Update the design to use the new Group variable
design(diagdds) <- ~ Group

# Re-run DESeq2 analysis with the updated design
diagdds <- DESeq(diagdds)

resultsNames(diagdds)

# ---- Step 2: Perform Direct Comparisons ---- #
# Compare specific conditions

res_Root_D <- results(diagdds, contrast=c("Group", "ROOT_D_Y", "ROOT_D_N"))
res_Root_C <- results(diagdds, contrast=c("Group", "ROOT_C_Y", "ROOT_C_N"))
res_Root_R <- results(diagdds, contrast=c("Group", "ROOT_R_Y", "ROOT_R_N"))

res_Stem_D <- results(diagdds, contrast=c("Group", "STEM_D_Y", "STEM_D_N"))
res_Stem_C <- results(diagdds, contrast=c("Group", "STEM_C_Y", "STEM_C_N"))
res_Stem_R <- results(diagdds, contrast=c("Group", "STEM_R_Y", "STEM_R_N"))

res_Leaf_D <- results(diagdds, contrast=c("Group", "LEAF_D_Y", "LEAF_D_N"))
res_Leaf_C <- results(diagdds, contrast=c("Group", "LEAF_C_Y", "LEAF_C_N"))
res_Leaf_R <- results(diagdds, contrast=c("Group", "LEAF_R_Y", "LEAF_R_N"))


# Create a list to hold each result and add labels for each comparison
results_list <- list()

# Add root-related results to the list
results_list$Root_D <- as.data.frame(res_Root_D)
results_list$Root_C <- as.data.frame(res_Root_C)
results_list$Root_R <- as.data.frame(res_Root_R)

# Add stem-related results to the list
results_list$Stem_D <- as.data.frame(res_Stem_D)
results_list$Stem_C <- as.data.frame(res_Stem_C)
results_list$Stem_R <- as.data.frame(res_Stem_R)

# Add leaf-related results to the list
results_list$Leaf_D <- as.data.frame(res_Leaf_D)
results_list$Leaf_C <- as.data.frame(res_Leaf_C)
results_list$Leaf_R <- as.data.frame(res_Leaf_R)

# Now combine all the results into one data frame and label each result
combined_results <- bind_rows(results_list, .id = "Comparison")

# Filter based on padj value
filtered_results <- combined_results %>%
  filter(padj <= 0.05)

# Filter based on log2FoldChange
filtered_results <- filtered_results %>%
  filter(log2FoldChange < -1 | log2FoldChange > 1)

#Storing tax table
tax_table_ps <- tax_table(ps_genus)

# Match Genus names from `tax_table_ps`
filtered_results$Genus <- sapply(rownames(filtered_results), function(row_name) {
  if (row_name %in% rownames(tax_table_ps)) {
    tax_table_ps@.Data[row_name, "Genus"]
  } else {
    NA
  }
})

# Remove rows with NA Genus
final_results <- filtered_results %>%
  filter(!is.na(Genus))

# Order Genera by their maximum log2FoldChange
genus_order <- final_results %>%
  group_by(Genus) %>%
  summarize(max_log2FoldChange = -max(log2FoldChange, na.rm = TRUE)) %>%
  arrange(desc(max_log2FoldChange))

# Ensure Genus levels are ordered
final_results$Genus <- factor(final_results$Genus, levels = genus_order$Genus)

# Step 1: Ensure all Genus-Comparison pairs are present, even if no data exists for them
all_combinations <- expand.grid(
  Genus = unique(final_results$Genus),
  Comparison = unique(final_results$Comparison)
)

# Merge with final_results to ensure every combination exists, even without data
heatmap_data_complete <- merge(all_combinations, final_results, by = c("Genus", "Comparison"), all.x = TRUE)

# Replace NAs in log2FoldChange with 0 (or choose another value as needed)
heatmap_data_complete$log2FoldChange[is.na(heatmap_data_complete$log2FoldChange)] <- 0

# Step 2: Melt the data for ggplot
heatmap_data_melted <- heatmap_data_complete %>%
  select(Genus, Comparison, log2FoldChange) %>%
  melt(id.vars = c("Genus", "Comparison"), variable.name = "Metric", value.name = "Value")

# Step 2.1: Get the top 20 most differentially abundant genera based on log2FoldChange
top_20_genus <- heatmap_data_complete %>%
  arrange(desc(abs(log2FoldChange))) %>%  # Sort by absolute value of log2FoldChange
  slice_head(n = 500) %>%  # Select the top 20 rows
  pull(Genus)  # Extract the genus names

# Step 3: Filter to retain only the top 20 genera in the melted data
heatmap_data_melted_top20 <- heatmap_data_melted %>%
  filter(Genus %in% top_20_genus)

heatmap_data_melted_top20 <- heatmap_data_melted_top20 %>%
  mutate(Comparison = recode(Comparison, 
                            "Stem_D" = "Stem - Rain Exclusion", 
                            "Stem_C" = "Stem - Control", 
                            "Stem_R" = "Stem - Ringbarked", 
                            "Root_D" = "Root - Rain Exclusion", 
                            "Root_C" = "Root - Control", 
                            "Root_R" = "Root - Ringbarked",
                            "Leaf_D" = "Leaf - Rain Exclusion", 
                            "Leaf_C" = "Leaf - Control", 
                            "Leaf_R" = "Leaf - Ringbarked"
                            ))

# Reorder the 'Comparison' factor levels
heatmap_data_melted_top20$Comparison <- factor(heatmap_data_melted_top20$Comparison, 
                                                levels = c("Leaf - Control", "Leaf - Rain Exclusion", "Leaf - Ringbarked", "Stem - Control", "Stem - Rain Exclusion", "Stem - Ringbarked", "Root - Control", "Root - Rain Exclusion", "Root - Ringbarked"))

# Plot the heatmap
DAA_Plot_LPOST_16S_genus <- ggplot(heatmap_data_melted_top20, aes(x = Comparison, y = Genus, fill = Value)) +
  geom_tile(color = "black", size = 0.7) +  # Add thicker black borders for every cell
  scale_fill_gradient2(
    low = "blue", mid = "grey", high = "red",
    midpoint = 0, 
    name = "log2FoldChange",
    limits = c(-8, 8),  # Set custom limits
    breaks = seq(-8, 8, by = 2)
  ) + 
  labs(
    title = NULL,
    x = NULL,
    y = "Genus"
  ) +
  theme_minimal(base_size = 14) +  # Increased base font size for consistency
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 30, face = "bold", colour = "black"),  # Larger and bold X axis text
    axis.text.y = element_text(size = 30, face = "bold", colour = "black"),  # Larger and bold Y axis text
    axis.title.x = element_text(size = 30, face = "bold", colour = "black"),  # Bold and larger X axis title (if any)
    axis.title.y = element_text(size = 30, face = "bold", colour = "black"),  # Bold and larger Y axis title
    plot.title = element_text(hjust = 0.5, size = 18, face = "bold"),  # Larger and bold title (if used)
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.title = element_text(size = 30, face = "bold", margin = margin(b = 20)),
    legend.text = element_text(size = 30, face = "bold"),
    legend.key.height = unit(2, "cm"),  # Increase the height of the legend bar
    legend.key.width = unit(0.5, "cm")  # Increase the width of the legend bar
  )

# Print the plot
print(DAA_Plot_LPOST_16S_genus)
```

#DAA - ITS - TP3 - Genus - AOD
```{r}
# Load necessary libraries
library(DESeq2)
library(ggplot2)
library(dplyr)
library(phyloseq)
library(reshape2)

# Filter phyloseq object for POST conditions
POST_ITS_opt_1 <- microViz::ps_filter(ps_ITS, 
                                       grepl("ROOT|LEAF|STEM", Organ) & 
                                       grepl("\\bPOST\\b", Time))

# Aggregate to genus level
ps_genus <- tax_glom(POST_ITS_opt_1, taxrank = "Genus")

# Add a pseudocount of 1
otu_table(ps_genus) <- otu_table(ps_genus) + 1

# Create DESeq2 object with the original design formula
diagdds <- phyloseq_to_deseq2(ps_genus, ~ Organ + Treatment + AOD + Organ:Treatment + Organ:AOD + Organ:Treatment:AOD + Organ:AOD:Treatment)

# Perform DESeq2 analysis
diagdds_res <- DESeq(diagdds, test = "Wald", fitType = "parametric")

# Inspect result names
resultsNames(diagdds_res)

# ---- Step 1: Update the Design for Specific Condition Comparisons ---- #
# Create a composite factor combining Organ, Treatment, and AOD
diagdds$Group <- factor(paste(diagdds$Organ, diagdds$Treatment, diagdds$AOD, sep="_"))

# Update the design to use the new Group variable
design(diagdds) <- ~ Group

# Re-run DESeq2 analysis with the updated design
diagdds <- DESeq(diagdds)

resultsNames(diagdds)

# ---- Step 2: Perform Direct Comparisons ---- #
# Compare specific conditions

res_Root_D <- results(diagdds, contrast=c("Group", "ROOT_D_Y", "ROOT_D_N"))
res_Root_C <- results(diagdds, contrast=c("Group", "ROOT_C_Y", "ROOT_C_N"))
res_Root_R <- results(diagdds, contrast=c("Group", "ROOT_R_Y", "ROOT_R_N"))

res_Stem_D <- results(diagdds, contrast=c("Group", "STEM_D_Y", "STEM_D_N"))
res_Stem_C <- results(diagdds, contrast=c("Group", "STEM_C_Y", "STEM_C_N"))
res_Stem_R <- results(diagdds, contrast=c("Group", "STEM_R_Y", "STEM_R_N"))


# Create a list to hold each result and add labels for each comparison
results_list <- list()

# Add root-related results to the list
results_list$Root_D <- as.data.frame(res_Root_D)
results_list$Root_C <- as.data.frame(res_Root_C)
results_list$Root_R <- as.data.frame(res_Root_R)

# Add stem-related results to the list
results_list$Stem_D <- as.data.frame(res_Stem_D)
results_list$Stem_C <- as.data.frame(res_Stem_C)
results_list$Stem_R <- as.data.frame(res_Stem_R)

# Now combine all the results into one data frame and label each result
combined_results <- bind_rows(results_list, .id = "Comparison")

# Filter based on padj value
filtered_results <- combined_results %>%
  filter(padj <= 0.05)

# Filter based on log2FoldChange
filtered_results <- filtered_results %>%
  filter(log2FoldChange < -1 | log2FoldChange > 1)

#Storing tax table
tax_table_ps <- tax_table(ps_genus)

# Match Genus names from `tax_table_ps`
filtered_results$Genus <- sapply(rownames(filtered_results), function(row_name) {
  if (row_name %in% rownames(tax_table_ps)) {
    tax_table_ps@.Data[row_name, "Genus"]
  } else {
    NA
  }
})

# Remove rows with NA Genus
final_results <- filtered_results %>%
  filter(!is.na(Genus))

# Order Genera by their maximum log2FoldChange
genus_order <- final_results %>%
  group_by(Genus) %>%
  summarize(max_log2FoldChange = -max(log2FoldChange, na.rm = TRUE)) %>%
  arrange(desc(max_log2FoldChange))

# Ensure Genus levels are ordered
final_results$Genus <- factor(final_results$Genus, levels = genus_order$Genus)

# Step 1: Ensure all Genus-Comparison pairs are present, even if no data exists for them
all_combinations <- expand.grid(
  Genus = unique(final_results$Genus),
  Comparison = unique(final_results$Comparison)
)

# Merge with final_results to ensure every combination exists, even without data
heatmap_data_complete <- merge(all_combinations, final_results, by = c("Genus", "Comparison"), all.x = TRUE)

# Replace NAs in log2FoldChange with 0 (or choose another value as needed)
heatmap_data_complete$log2FoldChange[is.na(heatmap_data_complete$log2FoldChange)] <- 0

# Step 2: Melt the data for ggplot
heatmap_data_melted <- heatmap_data_complete %>%
  select(Genus, Comparison, log2FoldChange) %>%
  melt(id.vars = c("Genus", "Comparison"), variable.name = "Metric", value.name = "Value")

# Step 2.1: Get the top 20 most differentially abundant genera based on log2FoldChange
top_20_genus <- heatmap_data_complete %>%
  arrange(desc(abs(log2FoldChange))) %>%  # Sort by absolute value of log2FoldChange
  slice_head(n = 500) %>%  # Select the top 20 rows
  pull(Genus)  # Extract the genus names

# Step 3: Filter to retain only the top 20 genera in the melted data
heatmap_data_melted_top20 <- heatmap_data_melted %>%
  filter(Genus %in% top_20_genus)

# Modify the 'Comparison' column
heatmap_data_melted_top20 <- heatmap_data_melted_top20 %>%
  mutate(Comparison = recode(Comparison, 
                            "Stem_D" = "Stem - Rain Exclusion", 
                            "Stem_C" = "Stem - Control", 
                            "Stem_R" = "Stem - Ringbarked", 
                            "Root_D" = "Root - Rain Exclusion", 
                            "Root_C" = "Root - Control", 
                            "Root_R" = "Root - Ringbarked"))

# Reorder the 'Comparison' factor levels
heatmap_data_melted_top20$Comparison <- factor(heatmap_data_melted_top20$Comparison, 
                                                levels = c("Stem - Control", "Stem - Rain Exclusion", "Stem - Ringbarked", 
                                                           "Root - Control", "Root - Rain Exclusion", "Root - Ringbarked"))

# Plot the heatmap
DAA_Plot_POST_ITS_genus <- ggplot(heatmap_data_melted_top20, aes(x = Comparison, y = Genus, fill = Value)) +
  geom_tile(color = "black", size = 0.7) +  # Add thicker black borders for every cell
  scale_fill_gradient2(
    low = "blue", mid = "grey", high = "red",
    midpoint = 0, 
    name = "log2FoldChange",
    limits = c(-8, 8),  # Set custom limits
    breaks = seq(-8, 8, by = 2)
  ) + 
  labs(
    title = NULL,
    x = NULL,
    y = "Genus"
  ) +
  theme_minimal(base_size = 14) +  # Increased base font size for consistency
  theme_minimal(base_size = 14) +  # Increased base font size for consistency
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 30, face = "bold", colour = "black"),  # Larger and bold X axis text
    axis.text.y = element_text(size = 30, face = "bold", colour = "black"),  # Larger and bold Y axis text
    axis.title.x = element_text(size = 30, face = "bold", colour = "black"),  # Bold and larger X axis title (if any)
    axis.title.y = element_text(size = 30, face = "bold", colour = "black"),  # Bold and larger Y axis title
    plot.title = element_text(hjust = 0.5, size = 18, face = "bold"),  # Larger and bold title (if used)
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.title = element_text(size = 30, face = "bold", margin = margin(b = 20)),
    legend.text = element_text(size = 30, face = "bold"),
    legend.key.height = unit(2, "cm"),  # Increase the height of the legend bar
    legend.key.width = unit(0.5, "cm")  # Increase the width of the legend bar
  )

# Print the plot
print(DAA_Plot_POST_ITS_genus)
```

#DAA - ITS - TP4 - Genus - AOD
```{r}
# Load necessary libraries
library(DESeq2)
library(ggplot2)
library(dplyr)
library(phyloseq)
library(reshape2)

# Filter phyloseq object for LPOST conditions
LPOST_ITS_opt_1 <- microViz::ps_filter(ps_ITS, 
                                       grepl("ROOT|LEAF|STEM", Organ) & 
                                       grepl("\\bLPOST\\b", Time))

# Aggregate to genus level
ps_genus <- tax_glom(LPOST_ITS_opt_1, taxrank = "Genus")

# Add a pseudocount of 1
otu_table(ps_genus) <- otu_table(ps_genus) + 1

# Create DESeq2 object with the original design formula
diagdds <- phyloseq_to_deseq2(ps_genus, ~ Organ + Treatment + AOD + Organ:Treatment + Organ:AOD + Organ:Treatment:AOD + Organ:AOD:Treatment)

# Perform DESeq2 analysis
diagdds_res <- DESeq(diagdds, test = "Wald", fitType = "parametric")

# Inspect result names
resultsNames(diagdds_res)

# ---- Step 1: Update the Design for Specific Condition Comparisons ---- #
# Create a composite factor combining Organ, Treatment, and AOD
diagdds$Group <- factor(paste(diagdds$Organ, diagdds$Treatment, diagdds$AOD, sep="_"))

# Update the design to use the new Group variable
design(diagdds) <- ~ Group

# Re-run DESeq2 analysis with the updated design
diagdds <- DESeq(diagdds)

resultsNames(diagdds)

# ---- Step 2: Perform Direct Comparisons ---- #
# Compare specific conditions

res_Root_D <- results(diagdds, contrast=c("Group", "ROOT_D_Y", "ROOT_D_N"))
res_Root_C <- results(diagdds, contrast=c("Group", "ROOT_C_Y", "ROOT_C_N"))
res_Root_R <- results(diagdds, contrast=c("Group", "ROOT_R_Y", "ROOT_R_N"))

res_Stem_D <- results(diagdds, contrast=c("Group", "STEM_D_Y", "STEM_D_N"))
res_Stem_C <- results(diagdds, contrast=c("Group", "STEM_C_Y", "STEM_C_N"))
res_Stem_R <- results(diagdds, contrast=c("Group", "STEM_R_Y", "STEM_R_N"))

res_Leaf_D <- results(diagdds, contrast=c("Group", "LEAF_D_Y", "LEAF_D_N"))
res_Leaf_C <- results(diagdds, contrast=c("Group", "LEAF_C_Y", "LEAF_C_N"))
res_Leaf_R <- results(diagdds, contrast=c("Group", "LEAF_R_Y", "LEAF_R_N"))


# Create a list to hold each result and add labels for each comparison
results_list <- list()

# Add root-related results to the list
results_list$Root_D <- as.data.frame(res_Root_D)
results_list$Root_C <- as.data.frame(res_Root_C)
results_list$Root_R <- as.data.frame(res_Root_R)

# Add stem-related results to the list
results_list$Stem_D <- as.data.frame(res_Stem_D)
results_list$Stem_C <- as.data.frame(res_Stem_C)
results_list$Stem_R <- as.data.frame(res_Stem_R)

# Add leaf-related results to the list
results_list$Leaf_D <- as.data.frame(res_Leaf_D)
results_list$Leaf_C <- as.data.frame(res_Leaf_C)
results_list$Leaf_R <- as.data.frame(res_Leaf_R)

# Now combine all the results into one data frame and label each result
combined_results <- bind_rows(results_list, .id = "Comparison")

# Filter based on padj value
filtered_results <- combined_results %>%
  filter(padj <= 0.05)

# Filter based on log2FoldChange
filtered_results <- filtered_results %>%
  filter(log2FoldChange < -1 | log2FoldChange > 1)

#Storing tax table
tax_table_ps <- tax_table(ps_genus)

# Match Genus names from `tax_table_ps`
filtered_results$Genus <- sapply(rownames(filtered_results), function(row_name) {
  if (row_name %in% rownames(tax_table_ps)) {
    tax_table_ps@.Data[row_name, "Genus"]
  } else {
    NA
  }
})

# Remove rows with NA Genus
final_results <- filtered_results %>%
  filter(!is.na(Genus))

# Order Genera by their maximum log2FoldChange
genus_order <- final_results %>%
  group_by(Genus) %>%
  summarize(max_log2FoldChange = -max(log2FoldChange, na.rm = TRUE)) %>%
  arrange(desc(max_log2FoldChange))

# Ensure Genus levels are ordered
final_results$Genus <- factor(final_results$Genus, levels = genus_order$Genus)

# Step 1: Ensure all Genus-Comparison pairs are present, even if no data exists for them
all_combinations <- expand.grid(
  Genus = unique(final_results$Genus),
  Comparison = unique(final_results$Comparison)
)

# Merge with final_results to ensure every combination exists, even without data
heatmap_data_complete <- merge(all_combinations, final_results, by = c("Genus", "Comparison"), all.x = TRUE)

# Replace NAs in log2FoldChange with 0 (or choose another value as needed)
heatmap_data_complete$log2FoldChange[is.na(heatmap_data_complete$log2FoldChange)] <- 0

# Step 2: Melt the data for ggplot
heatmap_data_melted <- heatmap_data_complete %>%
  select(Genus, Comparison, log2FoldChange) %>%
  melt(id.vars = c("Genus", "Comparison"), variable.name = "Metric", value.name = "Value")

# Step 2.1: Get the top 20 most differentially abundant genera based on log2FoldChange
top_20_genus <- heatmap_data_complete %>%
  arrange(desc(abs(log2FoldChange))) %>%  # Sort by absolute value of log2FoldChange
  slice_head(n = 500) %>%  # Select the top 20 rows
  pull(Genus)  # Extract the genus names

# Step 3: Filter to retain only the top 20 genera in the melted data
heatmap_data_melted_top20 <- heatmap_data_melted %>%
  filter(Genus %in% top_20_genus)

heatmap_data_melted_top20 <- heatmap_data_melted_top20 %>%
  mutate(Comparison = recode(Comparison, 
                            "Stem_D" = "Stem - Rain Exclusion", 
                            "Stem_C" = "Stem - Control", 
                            "Stem_R" = "Stem - Ringbarked", 
                            "Root_D" = "Root - Rain Exclusion", 
                            "Root_C" = "Root - Control", 
                            "Root_R" = "Root - Ringbarked",
                            "Leaf_D" = "Leaf - Rain Exclusion", 
                            "Leaf_C" = "Leaf - Control", 
                            "Leaf_R" = "Leaf - Ringbarked"
                            ))

# Reorder the 'Comparison' factor levels
heatmap_data_melted_top20$Comparison <- factor(heatmap_data_melted_top20$Comparison, 
                                                levels = c("Leaf - Control", "Leaf - Rain Exclusion", "Leaf - Ringbarked", "Stem - Control", "Stem - Rain Exclusion", "Stem - Ringbarked", "Root - Control", "Root - Rain Exclusion", "Root - Ringbarked"))

# Plot the heatmap
DAA_Plot_LPOST_ITS_genus <- ggplot(heatmap_data_melted_top20, aes(x = Comparison, y = Genus, fill = Value)) +
  geom_tile(color = "black", size = 0.7) +  # Add thicker black borders for every cell
  scale_fill_gradient2(
    low = "blue", mid = "grey", high = "red",
    midpoint = 0, 
    name = "log2FoldChange",
    limits = c(-8, 8),  # Set custom limits
    breaks = seq(-8, 8, by = 2)
  ) + 
  labs(
    title = NULL,
    x = NULL,
    y = "Genus"
  ) +
  theme_minimal(base_size = 14) +  # Increased base font size for consistency
  theme_minimal(base_size = 14) +  # Increased base font size for consistency
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 30, face = "bold", colour = "black"),  # Larger and bold X axis text
    axis.text.y = element_text(size = 30, face = "bold", colour = "black"),  # Larger and bold Y axis text
    axis.title.x = element_text(size = 30, face = "bold", colour = "black"),  # Bold and larger X axis title (if any)
    axis.title.y = element_text(size = 30, face = "bold", colour = "black"),  # Bold and larger Y axis title
    plot.title = element_text(hjust = 0.5, size = 18, face = "bold"),  # Larger and bold title (if used)
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.title = element_text(size = 30, face = "bold", margin = margin(b = 20)),
    legend.text = element_text(size = 30, face = "bold"),
    legend.key.height = unit(2, "cm"),  # Increase the height of the legend bar
    legend.key.width = unit(0.5, "cm")  # Increase the width of the legend bar
  )

# Print the plot
print(DAA_Plot_LPOST_ITS_genus)
```

#Combining and saving graphs
```{r}

#Combining 16S phylum and saving
# Adjust position of the tags to move them much further to the left
plot1 <- DAA_Plot_POST_16S
plot2 <- DAA_Plot_LPOST_16S

combined_plot <- plot_grid(
  plot1, plot2,             # Combine the two plots side by side
  labels = c("A", "B"),     # Label the plots as "A" and "B"
  label_size = 30,          # Set the size of the labels
  label_fontface = 'bold',  # Set the boldness of the labels
  ncol = 2,                 # Number of columns for the layout (2 side-by-side)
  rel_widths = c(0.47, 0.53)  # Adjust the relative width of the plots (40% for plot1, 60% for plot2)
)

ggsave("D:\\PhD_Bioinformatics\\Thesis_Resubmission\\Images\\DAA_16S_Phylum_Post_and_LPOST.png", combined_plot, width = 25, height = 10, dpi = 600, bg = "white")

#Combining ITS class and saving
# Adjust position of the tags to move them much further to the left
plot1 <- DAA_Plot_POST_ITS
plot2 <- DAA_Plot_LPOST_ITS

combined_plot <- plot_grid(
  plot1, plot2,             # Combine the two plots side by side
  labels = c("A", "B"),     # Label the plots as "A" and "B"
  label_size = 30,          # Set the size of the labels
  label_fontface = 'bold',  # Set the boldness of the labels
  ncol = 2,                 # Number of columns for the layout (2 side-by-side)
  rel_widths = c(0.47, 0.53)  # Adjust the relative width of the plots (40% for plot1, 60% for plot2)
)

ggsave("D:\\PhD_Bioinformatics\\Thesis_Resubmission\\Images\\DAA_ITS_Class_Post_and_LPOST.png", combined_plot, width = 25, height = 10, dpi = 600, bg = "white")

#Combining genus 16S POST and LPOST - bacteria

plot1 <- DAA_Plot_POST_16S_genus
plot2 <- DAA_Plot_LPOST_16S_genus

combined_plot <- plot_grid(
  plot1, plot2,             # Combine the two plots side by side
  labels = c("A", "B"),     # Label the plots as "A" and "B"
  label_size = 26,          # Set the size of the labels
  label_fontface = 'bold',  # Set the boldness of the labels
  ncol = 2,                 # Number of columns for the layout (2 side-by-side)
  rel_widths = c(0.45, 0.55)  # Adjust the relative width of the plots (40% for plot1, 60% for plot2)
)

ggsave("D:\\PhD_Bioinformatics\\Thesis_Resubmission\\Images\\DAA_16S_genus_Post_and_LPOST_all.png", combined_plot, width = 32, height = 36, dpi = 600, bg = "white")


#Combining genus 16S POST and LPOST - fungi

plot1 <- DAA_Plot_POST_ITS_genus
plot2 <- DAA_Plot_LPOST_ITS_genus

combined_plot <- plot_grid(
  plot1, plot2,             # Combine the two plots side by side
  labels = c("A", "B"),     # Label the plots as "A" and "B"
  label_size = 30,          # Set the size of the labels
  label_fontface = 'bold',  # Set the boldness of the labels
  ncol = 2,                 # Number of columns for the layout (2 side-by-side)
  rel_widths = c(0.48, 0.52)  # Adjust the relative width of the plots (40% for plot1, 60% for plot2)
)

ggsave("D:\\PhD_Bioinformatics\\Thesis_Resubmission\\Images\\DAA_ITS_genus_Post_and_LPOST_all.png", combined_plot, width = 32, height = 36, dpi = 600, bg = "white")
```


#Graphing for soil moisture and stem humidity index -----------------
#Loading packages
```{r}
library(readxl)
library(ggplot2)
library(lubridate)
library(dplyr)
library(purrr)
library(readr)
library(stringr)
library(forcats)
```

#Loading excel documents updated
```{r}
# Function to load all sheets from an Excel file into the global environment
load_excel_sheets <- function(file_path, prefix) {
  sheet_names <- excel_sheets(file_path)
  sheet_data <- lapply(sheet_names, function(sheet) {
    read_excel(file_path, sheet = sheet)
  })
  
  # Assign names to the list elements
  names(sheet_data) <- sheet_names
  
  # Convert list elements into separate data frames with prefixed names
  for (sheet in sheet_names) {
    assign(paste0(prefix, "_", sheet), sheet_data[[sheet]], envir = .GlobalEnv)
  }
  
  # Print loaded sheet names
  cat("Loaded sheets from", file_path, "\n")
  print(paste0(prefix, "_", sheet_names))
}

# Define file paths
file_paths <- list(
  Control = "D:\\PhD_Bioinformatics\\1BIG_EXPERIMENT\\SapFlow\\wetransfer_data-oct-2024_2024-10-11_1257\\Control.xlsx",
  Drought = "D:\\PhD_Bioinformatics\\1BIG_EXPERIMENT\\SapFlow\\wetransfer_data-oct-2024_2024-10-11_1257\\Drought.xlsx",
  Ringbarked = "D:\\PhD_Bioinformatics\\1BIG_EXPERIMENT\\SapFlow\\wetransfer_data-oct-2024_2024-10-11_1257\\Ringbarked.xlsx"
)

# Load each file
lapply(names(file_paths), function(prefix) {
  load_excel_sheets(file_paths[[prefix]], prefix)
})
```

#Checking environmental data
```{r}
# Get all object names in the global environment
all_objects <- ls()

# Count objects containing "Control"
control_count <- sum(grepl("^Control", all_objects))

# Count objects containing "Drought"
drought_count <- sum(grepl("^Drought", all_objects))

# Count objects containing "Ringbarked"
ringbarked_count <- sum(grepl("^Ringbarked", all_objects))

# Display the counts
cat("Control:", control_count, "\n")
cat("Drought:", drought_count, "\n")
cat("Ringbarked:", ringbarked_count, "\n")

#There are 24 tree talkers for each treatment
```

#Filter for month before and after time points
```{r}
# Define the date ranges for time points
date_ranges <- list(
  TP2 = interval(dmy("01.07.2021"), dmy("31.08.2021")),
  TP3 = interval(dmy("01.10.2021"), dmy("30.11.2021")),  # Corrected 31.11 to 30.11
  TP4 = interval(dmy("01.08.2022"), dmy("30.09.2022"))
)

# Get all relevant object names
filtered_objects <- ls(pattern = "^(Control|Drought|Ringbarked)")

# Loop through and filter each dataframe
for (obj_name in filtered_objects) {
  df <- get(obj_name)
  
  # Convert Server Date&Time to POSIXct
  if ("Server Date&Time" %in% names(df)) {
    df$DateTime <- dmy_hms(df[["Server Date&Time"]])
    
    # Combine all time intervals
    in_range <- Reduce(`|`, lapply(date_ranges, function(interval) df$DateTime %within% interval))
    
    # Filter the dataframe
    df_filtered <- df[in_range, ]
    
    # Reassign the filtered dataframe
    assign(obj_name, df_filtered)
  } else {
    warning(paste("Skipping", obj_name, "- no Server Date&Time column"))
  }
}
```

#Filtering for stem humidty
```{r}
# Define the columns to keep
columns_to_keep <- c("Server Date&Time", "Stem Humidity Index %")

# Get all objects in the global environment
all_objects <- ls()

# Filter for objects that are data frames and match your naming patterns
filtered_objects <- all_objects[grepl("^(Control|Drought|Ringbarked)", all_objects)]

# Loop through each object and keep only the specified columns
for (obj_name in filtered_objects) {
  df <- get(obj_name)
  
  # Only proceed if it's a data frame and contains the desired columns
  if (is.data.frame(df) && all(columns_to_keep %in% colnames(df))) {
    df_filtered <- df[, columns_to_keep, drop = FALSE]
    assign(obj_name, df_filtered)
  } else {
    warning(paste("Skipping", obj_name, "- missing required columns"))
  }
}
```

#Averaging across time point and treatment
```{r}
library(lubridate)
library(dplyr)

# Define time point intervals again for tagging
time_points <- list(
  TP2 = interval(dmy("01.07.2021"), dmy("31.08.2021")),
  TP3 = interval(dmy("01.10.2021"), dmy("30.11.2021")),
  TP4 = interval(dmy("01.08.2022"), dmy("30.09.2022"))
)

# Get all relevant data frame names
data_object_names <- ls(pattern = "^(Control|Drought|Ringbarked)")

# Initialize empty list to collect summarized data
summary_list <- list()

# Loop through each object
for (obj_name in data_object_names) {
  df <- get(obj_name)
  
  # Extract treatment from name
  treatment <- sub("_.*", "", obj_name)
  
  # Convert datetime
  df$DateTime <- dmy_hms(df[["Server Date&Time"]])
  df$Date <- as.Date(df$DateTime)
  
  # Assign TimePoint per row
  df <- df %>%
    mutate(
      TimePoint = case_when(
        DateTime %within% time_points$TP2 ~ "TP2",
        DateTime %within% time_points$TP3 ~ "TP3",
        DateTime %within% time_points$TP4 ~ "TP4",
        TRUE ~ NA_character_
      )
    ) %>%
    filter(!is.na(TimePoint))  # Keep only rows within defined time points
  
  # If any rows left after filtering, summarize them
  if (nrow(df) > 0) {
    daily_summary <- df %>%
      group_by(Date, TimePoint) %>%
      summarise(
        mean_growth = mean(`Stem Humidity Index %`, na.rm = TRUE),
        sd_growth = sd(`Stem Humidity Index %`, na.rm = TRUE),
        .groups = "drop"
      ) %>%
      mutate(
        Treatment = treatment,
        Tree = obj_name
      )
    
    summary_list[[obj_name]] <- daily_summary
  } else {
    warning(paste("No matching TimePoint data for:", obj_name))
  }
}

# Combine all summaries into one dataframe
summary_df <- bind_rows(summary_list)

# Remove infinite or extreme values
summary_df <- summary_df %>%
  filter(
    is.finite(mean_growth), is.finite(sd_growth),
    mean_growth >= -1000, mean_growth <= 1000,
    sd_growth >= -1000, sd_growth <= 1000
  )
```

#Plotting stem humidity index graph
```{r}
# Summarize across trees by Date, Treatment, and TimePoint
plot_df <- summary_df %>%
  group_by(TimePoint, Treatment, Date) %>%
  summarise(
    mean_growth = mean(mean_growth, na.rm = TRUE),
    sd_growth = sqrt(mean(sd_growth^2, na.rm = TRUE)),  
    .groups = "drop"
  )

# Sample date ranges and y positions for labels (staggered to avoid overlap)
sample_dates <- tibble::tibble(
  TimePoint = c("TP2", "TP2", "TP2", "TP3", "TP3", "TP4", "TP4", "TP4"),
  SampleType = c("BARK", "LEAF", "ROOT", "BARK", "ROOT", "BARK", "ROOT", "LEAF"),
  start_date = dmy(c("26-07-21", "02-08-21", "02-08-21", "13-10-21", "19-10-21", "16-08-22", "12-08-22", "22-08-22")),
  end_date = dmy(c("28-07-21", "04-08-21", "04-08-21", "15-10-21", "21-10-21", "18-08-22", "14-08-22", "24-08-22")),
  label_y = c(150, 140, 130, 150, 140, 150, 140, 130)
) %>%
  mutate(
    ymin = -60,
    ymax = 160
  )

# Relabel Treatment levels for clearer legend
plot_df$Treatment <- factor(plot_df$Treatment, 
                            levels = c("Control", "Drought", "Ringbarked"),
                            labels = c("Control", "Rain Exclusion", "Ringbarked"))

# Plot
plot <- ggplot(plot_df, aes(x = Date, y = mean_growth, color = Treatment)) +
  # Uniform shaded rectangles for sampling periods
  geom_rect(data = sample_dates,
            inherit.aes = FALSE,
            aes(xmin = start_date, xmax = end_date, ymin = ymin, ymax = ymax),
            fill = "grey60", alpha = 0.3, color = NA) +

  # Sample type labels
  geom_text(data = sample_dates,
            inherit.aes = FALSE,
            aes(x = start_date + (end_date - start_date)/2, y = label_y, label = SampleType),
            color = "black", size = 3, fontface = "bold") +

  # Ribbon for standard deviation (treatment fill restored here)
  geom_ribbon(aes(ymin = mean_growth - sd_growth, ymax = mean_growth + sd_growth, fill = Treatment),
              alpha = 0.15, color = NA) +

  # Line plot for treatment means
  geom_line(size = 1.2) +

  # Facet by TimePoint
  facet_wrap(~ TimePoint, scales = "free_x") +
  scale_x_date(date_labels = "%d-%m-%y") +
  ylim(-60, 160) +

  # Theme and labels
  theme_minimal(base_size = 16) +
  labs(
    title = "",
    x = NULL,
    y = "Stem Humidity Index (%)",
    color = "Treatment",
    fill = "Treatment"
  ) +

  # Color scales for lines and ribbons
  scale_color_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Dark2") +

  # Theme tweaks
  theme(
  strip.text = element_text(face = "bold", size = 11),
  axis.text.x = element_text(angle = 45, hjust = 1, size = 10, color = "black"),
  axis.text.y = element_text(size = 10, color = "black"),
  axis.title.y = element_text(size = 11),
  panel.grid.minor = element_blank(),
  panel.spacing = unit(1, "lines"),
  legend.position = "bottom",
  legend.title = element_text(face = "bold", size = 10),
  legend.text = element_text(size = 9)
)

# Save the plot
file_path <- "D:/PhD_Bioinformatics/1BIG_EXPERIMENT/SapFlow/Images/stem_humidity_fixed_ribbons.png"
ggsave(
  filename = file_path,
  plot = plot,
  width = 10,
  height = 5,
  dpi = 600,
  bg = "white"
)
```

#Creating graphs for soil moisture
```{r}
# Load required libraries
library(readr)
library(dplyr)
library(purrr)
library(lubridate)
library(tidyr)
library(stringr)

# Step 1: Get column names from each file (header row)
get_headers <- function(file_path) {
  read_csv(file_path, n_max = 0, show_col_types = FALSE) %>% names()
}

# Step 2: Read each CSV file, skip the units row, and apply proper headers
read_clean_data <- function(file_path) {
  headers <- get_headers(file_path)
  df <- read_csv(file_path, skip = 2, col_names = headers, show_col_types = FALSE)
  df$source_file <- basename(file_path)
  df
}

# Step 3: Load and combine all BACSTOP files
files <- list.files("D:/PhD_Bioinformatics/1BIG_EXPERIMENT/Moisture", 
                    pattern = "BACSTOP_\\d+_\\d+\\.csv$", 
                    full.names = TRUE)

soil_data <- map_dfr(files, read_clean_data)

#SM only
# Get column names that contain "SM"
sm_columns <- grep("SM", names(soil_data), value = TRUE)

# Count how many columns contain "SM"
length(sm_columns)

# Print the list of column names
sm_columns

# Step 4: Identify datetime column (assumed to be first), parse it correctly
datetime_col <- names(soil_data)[1]  # usually "Label"
soil_data <- soil_data %>%
  mutate(DateTime = dmy_hm(.data[[datetime_col]]),
         Date = as.Date(DateTime))

# Clean up column names to remove appended suffixes like ...3, ...14 etc.
names(soil_data) <- str_replace(names(soil_data), "\\.\\.\\..*$", "")

# Step 5: Select only soil moisture columns (ending in SM.Avg)
moisture_cols <- grep("SM\\.Avg$", names(soil_data), value = TRUE)

# Step 6: Pivot to long format for easier grouping
long_data <- soil_data %>%
  select(DateTime, Date, all_of(moisture_cols)) %>%
  pivot_longer(
    cols = all_of(moisture_cols),
    names_to = "Sensor",
    values_to = "Moisture"
  ) %>%
  mutate(Moisture = as.numeric(Moisture))  # Convert Moisture values to numeric

# Step 7: Extract metadata from Sensor names (Block, Treatment, Depth)
long_data <- long_data %>%
  mutate(
    Block = str_extract(Sensor, "B\\d+"),
    Treatment = str_extract(Sensor, "_[CD]_") %>% str_remove_all("_"),  # "C" or "D"
    Depth_cm = str_extract(Sensor, "_\\d+_") %>% str_remove_all("_") %>% as.numeric()
  )


# Define the date ranges for timepoints
date_ranges <- list(
  TP2 = interval(dmy("01.07.2021"), dmy("31.08.2021")),
  TP3 = interval(dmy("01.10.2021"), dmy("30.11.2021")),
  TP4 = interval(dmy("01.08.2022"), dmy("30.09.2022"))
)

# Step 8: Assign timepoint based on DateTime
long_data <- long_data %>%
  mutate(Timepoint = case_when(
    DateTime %within% date_ranges$TP2 ~ "Time Point 2",
    DateTime %within% date_ranges$TP3 ~ "Time Point 3",
    DateTime %within% date_ranges$TP4 ~ "Time Point 4",
    TRUE ~ NA_character_
  )) %>%
  filter(!is.na(Timepoint))


# Step 9: Group by Date, Depth, Treatment, and Timepoint  average across blocks
summary_by_treatment <- long_data %>%
  group_by(Timepoint, Date, Depth_cm, Treatment) %>%
  summarize(
    Moisture_Mean = mean(Moisture, na.rm = TRUE),
    Moisture_SD = sd(Moisture, na.rm = TRUE),
    .groups = "drop"
  )

# Step 10: View or export the results
print(summary_by_treatment)
```

#One average
```{r}
global_summary <- summary_by_treatment %>%
  group_by(Timepoint, Treatment) %>%
  summarize(
    Global_Mean = mean(Moisture_Mean, na.rm = TRUE),
    Global_SD = sqrt(mean(Moisture_SD^2, na.rm = TRUE)),  # Pooled SD approximation
    .groups = "drop"
  )

# View results
print(global_summary)
```

#Soil Moisture plotting 
```{r}
# Make sure Date column is Date class
summary_by_treatment$Date <- as.Date(summary_by_treatment$Date)

soil_moisture_all <- ggplot(summary_by_treatment, aes(x = Date, y = Moisture_Mean, color = Treatment)) +
  geom_line(size = 1) +
  geom_ribbon(aes(ymin = Moisture_Mean - Moisture_SD, ymax = Moisture_Mean + Moisture_SD, fill = Treatment), alpha = 0.2, color = NA) +
  facet_grid(Depth_cm ~ Timepoint, scales = "free_x") +
  scale_x_date(
    date_labels = "%d-%m-%y"  # numeric day-month-year, 2-digit year (e.g. 01-02-21)
  ) +
  labs(
    title = "",
    y = "Mean Soil Moisture (%)",
    color = "Treatment",
    fill = "Treatment"
  ) +
  theme_minimal() +
  theme(
    strip.background = element_rect(fill = "lightblue", color = "gray"),
    strip.text = element_text(face = "bold"),
    legend.position = "top",
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

# Save plot
file_path <- "D:/PhD_Bioinformatics/1BIG_EXPERIMENT/SapFlow/Images/soil_moisture_all.png"
ggsave(
  filename = file_path,
  plot = soil_moisture_all,
  width = 14,
  height = 12,
  dpi = 300,
  bg = "white"
)
```


#Averaging across all soil depths
```{r}
# Recode Treatment levels
summary_by_treatment <- summary_by_treatment %>%
  mutate(
    Treatment = fct_recode(Treatment,
                           "Control" = "C",
                           "Rain Exclusion" = "D")
  )

# Clean Timepoint column: convert "Time Point 2"  "TP2" etc
summary_by_treatment <- summary_by_treatment %>%
  mutate(
    Timepoint = case_when(
      grepl("2", Timepoint) ~ "TP2",
      grepl("3", Timepoint) ~ "TP3",
      grepl("4", Timepoint) ~ "TP4",
      TRUE ~ NA_character_
    ),
    Timepoint = factor(Timepoint, levels = c("TP2", "TP3", "TP4"))
  )

# Summarize across depths by Date, Treatment, and Timepoint
summary_across_depths <- summary_by_treatment %>%
  group_by(Timepoint, Treatment, Date) %>%
  summarise(
    Moisture_Mean_all_depths = mean(Moisture_Mean, na.rm = TRUE),
    Moisture_SD_all_depths = sqrt(mean(Moisture_SD^2, na.rm = TRUE)),
    .groups = "drop"
  ) %>%
  mutate(Date = as.Date(Date))

# Define sample dates, excluding first Bark sample in TP2
sample_dates <- tibble::tibble(
  Timepoint = factor(c("TP2", "TP2", "TP3", "TP3", "TP4", "TP4", "TP4"),
                     levels = c("TP2", "TP3", "TP4")),
  SampleType = c("LEAF", "ROOT", "BARK", "ROOT", "BARK", "ROOT", "LEAF"),
  start_date = dmy(c("02-08-21", "02-08-21", "13-10-21", "19-10-21", "16-08-22", "12-08-22", "22-08-22")),
  end_date = dmy(c("04-08-21", "04-08-21", "15-10-21", "21-10-21", "18-08-22", "14-08-22", "24-08-22")),
  label_y = c(20, 18, 20, 18, 26, 24, 22)
) %>%
  mutate(
    ymin = 5,
    ymax = 30
  )

# Plot
soil_moisture_avg_plot <- ggplot(summary_across_depths, aes(x = Date, y = Moisture_Mean_all_depths, color = Treatment, fill = Treatment)) +

  # Add SD ribbon back (slightly transparent, no border)
  geom_ribbon(aes(ymin = Moisture_Mean_all_depths - Moisture_SD_all_depths,
                  ymax = Moisture_Mean_all_depths + Moisture_SD_all_depths),
              alpha = 0.15, color = NA, inherit.aes = TRUE) +

  # Rectangles & labels for sample dates (no fill legend)
  geom_rect(data = sample_dates,
            inherit.aes = FALSE,
            aes(xmin = start_date, xmax = end_date, ymin = ymin, ymax = ymax),
            fill = "grey60", alpha = 0.3, color = NA) +

  geom_text(data = sample_dates,
            inherit.aes = FALSE,
            aes(x = start_date + (end_date - start_date)/2, y = label_y, label = SampleType),
            color = "black", size = 3, fontface = "bold") +

  geom_line(size = 1.2) +

  facet_wrap(~ Timepoint, scales = "free_x") +
  scale_x_date(date_labels = "%d-%m-%y") +
  coord_cartesian(ylim = c(5, 30)) +

  scale_color_brewer(palette = "Dark2") +
  scale_fill_brewer(palette = "Dark2", guide = "none") +  # hide fill legend

  theme_minimal(base_size = 16) +
  labs(
    title = "",
    x = NULL,
    y = "Soil Moisture (%)",
    color = "Treatment"
  ) +
  theme(
  strip.text = element_text(face = "bold", size = 11),
  axis.text.x = element_text(angle = 45, hjust = 1, size = 10, color = "black"),
  axis.text.y = element_text(size = 10, color = "black"),
  axis.title.y = element_text(size = 11),
  panel.grid.minor = element_blank(),
  panel.spacing = unit(1, "lines"),
  legend.position = "bottom",
  legend.title = element_text(face = "bold", size = 10),
  legend.text = element_text(size = 9)
)

# Save plot
file_path <- "D:/PhD_Bioinformatics/1BIG_EXPERIMENT/SapFlow/Images/soil_moisture_avg_depths_no_legend.png"
ggsave(
  filename = file_path,
  plot = soil_moisture_avg_plot,
  width = 10,
  height = 5,
  dpi = 600,
  bg = "white"
)
```